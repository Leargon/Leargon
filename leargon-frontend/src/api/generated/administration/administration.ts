/**
 * Generated by orval v8.4.0 ðŸº
 * Do not edit manually.
 * LÃ©argon API
 * REST API for LÃ©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdministrationChangePasswordRequest,
  UpdateUserRequest,
  UserResponse
} from '.././model';

import { customAxios } from '../../customAxios';




/**
 * Returns a list of all users in the system. Requires ROLE_ADMIN.
 * @summary Get all users
 */
export type getAllUsersResponse200 = {
  data: UserResponse[]
  status: 200
}

export type getAllUsersResponse401 = {
  data: void
  status: 401
}

export type getAllUsersResponse403 = {
  data: void
  status: 403
}

export type getAllUsersResponseSuccess = (getAllUsersResponse200) & {
  headers: Headers;
};
export type getAllUsersResponseError = (getAllUsersResponse401 | getAllUsersResponse403) & {
  headers: Headers;
};

export type getAllUsersResponse = (getAllUsersResponseSuccess | getAllUsersResponseError)

export const getGetAllUsersUrl = () => {


  

  return `/administration/users`
}

export const getAllUsers = async ( options?: RequestInit): Promise<getAllUsersResponse> => {
  
  return customAxios<getAllUsersResponse>(getGetAllUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAllUsersQueryKey = () => {
    return [
    `/administration/users`
    ] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = void


export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all users
 */

export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns detailed information about a specific user. Requires ROLE_ADMIN.
 * @summary Get user by ID
 */
export type getUserByIdResponse200 = {
  data: UserResponse
  status: 200
}

export type getUserByIdResponse401 = {
  data: void
  status: 401
}

export type getUserByIdResponse403 = {
  data: void
  status: 403
}

export type getUserByIdResponse404 = {
  data: void
  status: 404
}

export type getUserByIdResponseSuccess = (getUserByIdResponse200) & {
  headers: Headers;
};
export type getUserByIdResponseError = (getUserByIdResponse401 | getUserByIdResponse403 | getUserByIdResponse404) & {
  headers: Headers;
};

export type getUserByIdResponse = (getUserByIdResponseSuccess | getUserByIdResponseError)

export const getGetUserByIdUrl = (id: number,) => {


  

  return `/administration/users/${id}`
}

export const getUserById = async (id: number, options?: RequestInit): Promise<getUserByIdResponse> => {
  
  return customAxios<getUserByIdResponse>(getGetUserByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUserByIdQueryKey = (id: number,) => {
    return [
    `/administration/users/${id}`
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = void


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user by ID
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Updates user information including name, email, username, status, and roles. Cannot modify fallback admin user. Requires ROLE_ADMIN.
 * @summary Update user details
 */
export type updateUserResponse200 = {
  data: UserResponse
  status: 200
}

export type updateUserResponse401 = {
  data: void
  status: 401
}

export type updateUserResponse403 = {
  data: void
  status: 403
}

export type updateUserResponse404 = {
  data: void
  status: 404
}

export type updateUserResponse409 = {
  data: void
  status: 409
}

export type updateUserResponseSuccess = (updateUserResponse200) & {
  headers: Headers;
};
export type updateUserResponseError = (updateUserResponse401 | updateUserResponse403 | updateUserResponse404 | updateUserResponse409) & {
  headers: Headers;
};

export type updateUserResponse = (updateUserResponseSuccess | updateUserResponseError)

export const getUpdateUserUrl = (id: number,) => {


  

  return `/administration/users/${id}`
}

export const updateUser = async (id: number,
    updateUserRequest: UpdateUserRequest, options?: RequestInit): Promise<updateUserResponse> => {
  
  return customAxios<updateUserResponse>(getUpdateUserUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserRequest,)
  }
);}




export const getUpdateUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {id: number;data: UpdateUserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUser(id,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserRequest
    export type UpdateUserMutationError = void

    /**
 * @summary Update user details
 */
export const useUpdateUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {id: number;data: UpdateUserRequest},
        TContext
      > => {
      return useMutation(getUpdateUserMutationOptions(options), queryClient);
    }
    /**
 * Disables a user account (soft delete). Cannot delete fallback admin user. Requires ROLE_ADMIN.
 * @summary Soft-delete user
 */
export type deleteUserResponse200 = {
  data: UserResponse
  status: 200
}

export type deleteUserResponse401 = {
  data: void
  status: 401
}

export type deleteUserResponse403 = {
  data: void
  status: 403
}

export type deleteUserResponse404 = {
  data: void
  status: 404
}

export type deleteUserResponseSuccess = (deleteUserResponse200) & {
  headers: Headers;
};
export type deleteUserResponseError = (deleteUserResponse401 | deleteUserResponse403 | deleteUserResponse404) & {
  headers: Headers;
};

export type deleteUserResponse = (deleteUserResponseSuccess | deleteUserResponseError)

export const getDeleteUserUrl = (id: number,) => {


  

  return `/administration/users/${id}`
}

export const deleteUser = async (id: number, options?: RequestInit): Promise<deleteUserResponse> => {
  
  return customAxios<deleteUserResponse>(getDeleteUserUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = void

    /**
 * @summary Soft-delete user
 */
export const useDeleteUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: number},
        TContext
      > => {
      return useMutation(getDeleteUserMutationOptions(options), queryClient);
    }
    /**
 * Disables a user account, preventing login. Cannot disable fallback admin. Requires ROLE_ADMIN.
 * @summary Disable user account
 */
export type disableUserResponse200 = {
  data: UserResponse
  status: 200
}

export type disableUserResponse401 = {
  data: void
  status: 401
}

export type disableUserResponse403 = {
  data: void
  status: 403
}

export type disableUserResponse404 = {
  data: void
  status: 404
}

export type disableUserResponseSuccess = (disableUserResponse200) & {
  headers: Headers;
};
export type disableUserResponseError = (disableUserResponse401 | disableUserResponse403 | disableUserResponse404) & {
  headers: Headers;
};

export type disableUserResponse = (disableUserResponseSuccess | disableUserResponseError)

export const getDisableUserUrl = (id: number,) => {


  

  return `/administration/users/${id}/disable`
}

export const disableUser = async (id: number, options?: RequestInit): Promise<disableUserResponse> => {
  
  return customAxios<disableUserResponse>(getDisableUserUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getDisableUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['disableUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  disableUser(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DisableUserMutationResult = NonNullable<Awaited<ReturnType<typeof disableUser>>>
    
    export type DisableUserMutationError = void

    /**
 * @summary Disable user account
 */
export const useDisableUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableUser>>,
        TError,
        {id: number},
        TContext
      > => {
      return useMutation(getDisableUserMutationOptions(options), queryClient);
    }
    /**
 * Enables a disabled user account, allowing login. Requires ROLE_ADMIN.
 * @summary Enable user account
 */
export type enableUserResponse200 = {
  data: UserResponse
  status: 200
}

export type enableUserResponse401 = {
  data: void
  status: 401
}

export type enableUserResponse404 = {
  data: void
  status: 404
}

export type enableUserResponseSuccess = (enableUserResponse200) & {
  headers: Headers;
};
export type enableUserResponseError = (enableUserResponse401 | enableUserResponse404) & {
  headers: Headers;
};

export type enableUserResponse = (enableUserResponseSuccess | enableUserResponseError)

export const getEnableUserUrl = (id: number,) => {


  

  return `/administration/users/${id}/enable`
}

export const enableUser = async (id: number, options?: RequestInit): Promise<enableUserResponse> => {
  
  return customAxios<enableUserResponse>(getEnableUserUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getEnableUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof enableUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['enableUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  enableUser(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type EnableUserMutationResult = NonNullable<Awaited<ReturnType<typeof enableUser>>>
    
    export type EnableUserMutationError = void

    /**
 * @summary Enable user account
 */
export const useEnableUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enableUser>>,
        TError,
        {id: number},
        TContext
      > => {
      return useMutation(getEnableUserMutationOptions(options), queryClient);
    }
    /**
 * Locks a user account, preventing login. Cannot lock fallback admin. Requires ROLE_ADMIN.
 * @summary Lock user account
 */
export type lockUserResponse200 = {
  data: UserResponse
  status: 200
}

export type lockUserResponse401 = {
  data: void
  status: 401
}

export type lockUserResponse403 = {
  data: void
  status: 403
}

export type lockUserResponse404 = {
  data: void
  status: 404
}

export type lockUserResponseSuccess = (lockUserResponse200) & {
  headers: Headers;
};
export type lockUserResponseError = (lockUserResponse401 | lockUserResponse403 | lockUserResponse404) & {
  headers: Headers;
};

export type lockUserResponse = (lockUserResponseSuccess | lockUserResponseError)

export const getLockUserUrl = (id: number,) => {


  

  return `/administration/users/${id}/lock`
}

export const lockUser = async (id: number, options?: RequestInit): Promise<lockUserResponse> => {
  
  return customAxios<lockUserResponse>(getLockUserUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getLockUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof lockUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['lockUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lockUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  lockUser(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LockUserMutationResult = NonNullable<Awaited<ReturnType<typeof lockUser>>>
    
    export type LockUserMutationError = void

    /**
 * @summary Lock user account
 */
export const useLockUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lockUser>>,
        TError,
        {id: number},
        TContext
      > => {
      return useMutation(getLockUserMutationOptions(options), queryClient);
    }
    /**
 * Allows an administration to reset a user's password without knowing the current password. Cannot change fallback admin password. Requires ROLE_ADMIN.
 * @summary Change user password (admin)
 */
export type administrationChangePasswordResponse200 = {
  data: void
  status: 200
}

export type administrationChangePasswordResponse400 = {
  data: void
  status: 400
}

export type administrationChangePasswordResponse401 = {
  data: void
  status: 401
}

export type administrationChangePasswordResponse403 = {
  data: void
  status: 403
}

export type administrationChangePasswordResponse404 = {
  data: void
  status: 404
}

export type administrationChangePasswordResponseSuccess = (administrationChangePasswordResponse200) & {
  headers: Headers;
};
export type administrationChangePasswordResponseError = (administrationChangePasswordResponse400 | administrationChangePasswordResponse401 | administrationChangePasswordResponse403 | administrationChangePasswordResponse404) & {
  headers: Headers;
};

export type administrationChangePasswordResponse = (administrationChangePasswordResponseSuccess | administrationChangePasswordResponseError)

export const getAdministrationChangePasswordUrl = (id: number,) => {


  

  return `/administration/users/${id}/password`
}

export const administrationChangePassword = async (id: number,
    administrationChangePasswordRequest: AdministrationChangePasswordRequest, options?: RequestInit): Promise<administrationChangePasswordResponse> => {
  
  return customAxios<administrationChangePasswordResponse>(getAdministrationChangePasswordUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      administrationChangePasswordRequest,)
  }
);}




export const getAdministrationChangePasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof administrationChangePassword>>, TError,{id: number;data: AdministrationChangePasswordRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof administrationChangePassword>>, TError,{id: number;data: AdministrationChangePasswordRequest}, TContext> => {

const mutationKey = ['administrationChangePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof administrationChangePassword>>, {id: number;data: AdministrationChangePasswordRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  administrationChangePassword(id,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdministrationChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof administrationChangePassword>>>
    export type AdministrationChangePasswordMutationBody = AdministrationChangePasswordRequest
    export type AdministrationChangePasswordMutationError = void

    /**
 * @summary Change user password (admin)
 */
export const useAdministrationChangePassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof administrationChangePassword>>, TError,{id: number;data: AdministrationChangePasswordRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof administrationChangePassword>>,
        TError,
        {id: number;data: AdministrationChangePasswordRequest},
        TContext
      > => {
      return useMutation(getAdministrationChangePasswordMutationOptions(options), queryClient);
    }
    /**
 * Unlocks a previously locked user account. Requires ROLE_ADMIN.
 * @summary Unlock user account
 */
export type unlockUserResponse200 = {
  data: UserResponse
  status: 200
}

export type unlockUserResponse401 = {
  data: void
  status: 401
}

export type unlockUserResponse404 = {
  data: void
  status: 404
}

export type unlockUserResponseSuccess = (unlockUserResponse200) & {
  headers: Headers;
};
export type unlockUserResponseError = (unlockUserResponse401 | unlockUserResponse404) & {
  headers: Headers;
};

export type unlockUserResponse = (unlockUserResponseSuccess | unlockUserResponseError)

export const getUnlockUserUrl = (id: number,) => {


  

  return `/administration/users/${id}/unlock`
}

export const unlockUser = async (id: number, options?: RequestInit): Promise<unlockUserResponse> => {
  
  return customAxios<unlockUserResponse>(getUnlockUserUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getUnlockUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['unlockUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlockUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  unlockUser(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UnlockUserMutationResult = NonNullable<Awaited<ReturnType<typeof unlockUser>>>
    
    export type UnlockUserMutationError = void

    /**
 * @summary Unlock user account
 */
export const useUnlockUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unlockUser>>,
        TError,
        {id: number},
        TContext
      > => {
      return useMutation(getUnlockUserMutationOptions(options), queryClient);
    }
    
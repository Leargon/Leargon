/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * LÃ©argon API
 * REST API for LÃ©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdministrationChangePasswordRequest,
  UpdateUserRequest,
  UserResponse
} from '.././model';

import { customAxios } from '../../customAxios';




/**
 * Returns a list of all users in the system. Requires ROLE_ADMIN.
 * @summary Get all users
 */
export const getAllUsers = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse[]>(
      {url: `/administration/users`, method: 'GET', signal
    },
      );
    }
  



export const getGetAllUsersQueryKey = () => {
    return [
    `/administration/users`
    ] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = void


export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all users
 */

export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns detailed information about a specific user. Requires ROLE_ADMIN.
 * @summary Get user by ID
 */
export const getUserById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetUserByIdQueryKey = (id?: number,) => {
    return [
    `/administration/users/${id}`
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = void


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user by ID
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates user information including name, email, username, status, and roles. Cannot modify fallback admin user. Requires ROLE_ADMIN.
 * @summary Update user details
 */
export const updateUser = (
    id: number,
    updateUserRequest: UpdateUserRequest,
 ) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserRequest
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {id: number;data: UpdateUserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUser(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserRequest
    export type UpdateUserMutationError = void

    /**
 * @summary Update user details
 */
export const useUpdateUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {id: number;data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Disables a user account (soft delete). Cannot delete fallback admin user. Requires ROLE_ADMIN.
 * @summary Soft-delete user
 */
export const deleteUser = (
    id: number,
 ) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = void

    /**
 * @summary Soft-delete user
 */
export const useDeleteUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Disables a user account, preventing login. Cannot disable fallback admin. Requires ROLE_ADMIN.
 * @summary Disable user account
 */
export const disableUser = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}/disable`, method: 'POST', signal
    },
      );
    }
  


export const getDisableUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['disableUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  disableUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableUserMutationResult = NonNullable<Awaited<ReturnType<typeof disableUser>>>
    
    export type DisableUserMutationError = void

    /**
 * @summary Disable user account
 */
export const useDisableUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDisableUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Enables a disabled user account, allowing login. Requires ROLE_ADMIN.
 * @summary Enable user account
 */
export const enableUser = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}/enable`, method: 'POST', signal
    },
      );
    }
  


export const getEnableUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof enableUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['enableUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  enableUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnableUserMutationResult = NonNullable<Awaited<ReturnType<typeof enableUser>>>
    
    export type EnableUserMutationError = void

    /**
 * @summary Enable user account
 */
export const useEnableUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enableUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getEnableUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Locks a user account, preventing login. Cannot lock fallback admin. Requires ROLE_ADMIN.
 * @summary Lock user account
 */
export const lockUser = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}/lock`, method: 'POST', signal
    },
      );
    }
  


export const getLockUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof lockUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['lockUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lockUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  lockUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LockUserMutationResult = NonNullable<Awaited<ReturnType<typeof lockUser>>>
    
    export type LockUserMutationError = void

    /**
 * @summary Lock user account
 */
export const useLockUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lockUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getLockUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Allows an administration to reset a user's password without knowing the current password. Cannot change fallback admin password. Requires ROLE_ADMIN.
 * @summary Change user password (admin)
 */
export const administrationChangePassword = (
    id: number,
    administrationChangePasswordRequest: AdministrationChangePasswordRequest,
 ) => {
      
      
      return customAxios<void>(
      {url: `/administration/users/${id}/password`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: administrationChangePasswordRequest
    },
      );
    }
  


export const getAdministrationChangePasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof administrationChangePassword>>, TError,{id: number;data: AdministrationChangePasswordRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof administrationChangePassword>>, TError,{id: number;data: AdministrationChangePasswordRequest}, TContext> => {

const mutationKey = ['administrationChangePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof administrationChangePassword>>, {id: number;data: AdministrationChangePasswordRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  administrationChangePassword(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdministrationChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof administrationChangePassword>>>
    export type AdministrationChangePasswordMutationBody = AdministrationChangePasswordRequest
    export type AdministrationChangePasswordMutationError = void

    /**
 * @summary Change user password (admin)
 */
export const useAdministrationChangePassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof administrationChangePassword>>, TError,{id: number;data: AdministrationChangePasswordRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof administrationChangePassword>>,
        TError,
        {id: number;data: AdministrationChangePasswordRequest},
        TContext
      > => {

      const mutationOptions = getAdministrationChangePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Unlocks a previously locked user account. Requires ROLE_ADMIN.
 * @summary Unlock user account
 */
export const unlockUser = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse>(
      {url: `/administration/users/${id}/unlock`, method: 'POST', signal
    },
      );
    }
  


export const getUnlockUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['unlockUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlockUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  unlockUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnlockUserMutationResult = NonNullable<Awaited<ReturnType<typeof unlockUser>>>
    
    export type UnlockUserMutationError = void

    /**
 * @summary Unlock user account
 */
export const useUnlockUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unlockUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getUnlockUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
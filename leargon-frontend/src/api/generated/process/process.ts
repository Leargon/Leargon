/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * L√©argon API
 * REST API for L√©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddProcessEntityRequest,
  AssignBusinessDomainRequest,
  ClassificationAssignmentRequest,
  CreateProcessRequest,
  ErrorResponse,
  LocalizedText,
  ProcessDiagramResponse,
  ProcessResponse,
  ProcessTreeResponse,
  ProcessVersionResponse,
  SaveProcessDiagramRequest,
  UpdateProcessCodeRequest,
  UpdateProcessOwnerRequest,
  UpdateProcessTypeRequest,
  VersionDiffResponse
} from '.././model';

import { customAxios } from '../../customAxios';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Returns a list of all business processes.
 * @summary Get all processes
 */
export type getAllProcessesResponse200 = {
  data: ProcessResponse[]
  status: 200
}

export type getAllProcessesResponse401 = {
  data: void
  status: 401
}

export type getAllProcessesResponseSuccess = (getAllProcessesResponse200) & {
  headers: Headers;
};
export type getAllProcessesResponseError = (getAllProcessesResponse401) & {
  headers: Headers;
};

export type getAllProcessesResponse = (getAllProcessesResponseSuccess | getAllProcessesResponseError)

export const getGetAllProcessesUrl = () => {


  

  return `/processes`
}

export const getAllProcesses = async ( options?: RequestInit): Promise<getAllProcessesResponse> => {
  
  return customAxios<getAllProcessesResponse>(getGetAllProcessesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAllProcessesQueryKey = () => {
    return [
    `/processes`
    ] as const;
    }

    
export const getGetAllProcessesQueryOptions = <TData = Awaited<ReturnType<typeof getAllProcesses>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProcesses>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllProcessesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProcesses>>> = ({ signal }) => getAllProcesses({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProcesses>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllProcessesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProcesses>>>
export type GetAllProcessesQueryError = void


export function useGetAllProcesses<TData = Awaited<ReturnType<typeof getAllProcesses>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProcesses>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProcesses>>,
          TError,
          Awaited<ReturnType<typeof getAllProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProcesses<TData = Awaited<ReturnType<typeof getAllProcesses>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProcesses>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProcesses>>,
          TError,
          Awaited<ReturnType<typeof getAllProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProcesses<TData = Awaited<ReturnType<typeof getAllProcesses>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProcesses>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all processes
 */

export function useGetAllProcesses<TData = Awaited<ReturnType<typeof getAllProcesses>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProcesses>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProcessesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Creates a new business process. The creator becomes the process owner by default.
 * @summary Create a process
 */
export type createProcessResponse201 = {
  data: ProcessResponse
  status: 201
}

export type createProcessResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createProcessResponse401 = {
  data: void
  status: 401
}

export type createProcessResponseSuccess = (createProcessResponse201) & {
  headers: Headers;
};
export type createProcessResponseError = (createProcessResponse400 | createProcessResponse401) & {
  headers: Headers;
};

export type createProcessResponse = (createProcessResponseSuccess | createProcessResponseError)

export const getCreateProcessUrl = () => {


  

  return `/processes`
}

export const createProcess = async (createProcessRequest: CreateProcessRequest, options?: RequestInit): Promise<createProcessResponse> => {
  
  return customAxios<createProcessResponse>(getCreateProcessUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createProcessRequest,)
  }
);}




export const getCreateProcessMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProcess>>, TError,{data: CreateProcessRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof createProcess>>, TError,{data: CreateProcessRequest}, TContext> => {

const mutationKey = ['createProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProcess>>, {data: CreateProcessRequest}> = (props) => {
          const {data} = props ?? {};

          return  createProcess(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProcessMutationResult = NonNullable<Awaited<ReturnType<typeof createProcess>>>
    export type CreateProcessMutationBody = CreateProcessRequest
    export type CreateProcessMutationError = ErrorResponse | void

    /**
 * @summary Create a process
 */
export const useCreateProcess = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProcess>>, TError,{data: CreateProcessRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProcess>>,
        TError,
        {data: CreateProcessRequest},
        TContext
      > => {
      return useMutation(getCreateProcessMutationOptions(options), queryClient);
    }
    /**
 * Returns business processes as a hierarchical tree structure.
 * @summary Get process hierarchy
 */
export type getProcessTreeResponse200 = {
  data: ProcessTreeResponse[]
  status: 200
}

export type getProcessTreeResponse401 = {
  data: void
  status: 401
}

export type getProcessTreeResponseSuccess = (getProcessTreeResponse200) & {
  headers: Headers;
};
export type getProcessTreeResponseError = (getProcessTreeResponse401) & {
  headers: Headers;
};

export type getProcessTreeResponse = (getProcessTreeResponseSuccess | getProcessTreeResponseError)

export const getGetProcessTreeUrl = () => {


  

  return `/processes/tree`
}

export const getProcessTree = async ( options?: RequestInit): Promise<getProcessTreeResponse> => {
  
  return customAxios<getProcessTreeResponse>(getGetProcessTreeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetProcessTreeQueryKey = () => {
    return [
    `/processes/tree`
    ] as const;
    }

    
export const getGetProcessTreeQueryOptions = <TData = Awaited<ReturnType<typeof getProcessTree>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessTree>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProcessTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProcessTree>>> = ({ signal }) => getProcessTree({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProcessTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProcessTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getProcessTree>>>
export type GetProcessTreeQueryError = void


export function useGetProcessTree<TData = Awaited<ReturnType<typeof getProcessTree>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessTree>>,
          TError,
          Awaited<ReturnType<typeof getProcessTree>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessTree<TData = Awaited<ReturnType<typeof getProcessTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessTree>>,
          TError,
          Awaited<ReturnType<typeof getProcessTree>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessTree<TData = Awaited<ReturnType<typeof getProcessTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessTree>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get process hierarchy
 */

export function useGetProcessTree<TData = Awaited<ReturnType<typeof getProcessTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessTree>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProcessTreeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns detailed information about a specific business process.
 * @summary Get process by key
 */
export type getProcessByKeyResponse200 = {
  data: ProcessResponse
  status: 200
}

export type getProcessByKeyResponse401 = {
  data: void
  status: 401
}

export type getProcessByKeyResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getProcessByKeyResponseSuccess = (getProcessByKeyResponse200) & {
  headers: Headers;
};
export type getProcessByKeyResponseError = (getProcessByKeyResponse401 | getProcessByKeyResponse404) & {
  headers: Headers;
};

export type getProcessByKeyResponse = (getProcessByKeyResponseSuccess | getProcessByKeyResponseError)

export const getGetProcessByKeyUrl = (key: string,) => {


  

  return `/processes/${key}`
}

export const getProcessByKey = async (key: string, options?: RequestInit): Promise<getProcessByKeyResponse> => {
  
  return customAxios<getProcessByKeyResponse>(getGetProcessByKeyUrl(key),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetProcessByKeyQueryKey = (key: string,) => {
    return [
    `/processes/${key}`
    ] as const;
    }

    
export const getGetProcessByKeyQueryOptions = <TData = Awaited<ReturnType<typeof getProcessByKey>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessByKey>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProcessByKeyQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProcessByKey>>> = ({ signal }) => getProcessByKey(key, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProcessByKey>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProcessByKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getProcessByKey>>>
export type GetProcessByKeyQueryError = void | ErrorResponse


export function useGetProcessByKey<TData = Awaited<ReturnType<typeof getProcessByKey>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessByKey>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessByKey>>,
          TError,
          Awaited<ReturnType<typeof getProcessByKey>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessByKey<TData = Awaited<ReturnType<typeof getProcessByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessByKey>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessByKey>>,
          TError,
          Awaited<ReturnType<typeof getProcessByKey>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessByKey<TData = Awaited<ReturnType<typeof getProcessByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessByKey>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get process by key
 */

export function useGetProcessByKey<TData = Awaited<ReturnType<typeof getProcessByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessByKey>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProcessByKeyQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Permanently deletes a business process. Only the process owner or an admin can delete.
 * @summary Delete process
 */
export type deleteProcessResponse204 = {
  data: void
  status: 204
}

export type deleteProcessResponse401 = {
  data: void
  status: 401
}

export type deleteProcessResponse403 = {
  data: void
  status: 403
}

export type deleteProcessResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteProcessResponseSuccess = (deleteProcessResponse204) & {
  headers: Headers;
};
export type deleteProcessResponseError = (deleteProcessResponse401 | deleteProcessResponse403 | deleteProcessResponse404) & {
  headers: Headers;
};

export type deleteProcessResponse = (deleteProcessResponseSuccess | deleteProcessResponseError)

export const getDeleteProcessUrl = (key: string,) => {


  

  return `/processes/${key}`
}

export const deleteProcess = async (key: string, options?: RequestInit): Promise<deleteProcessResponse> => {
  
  return customAxios<deleteProcessResponse>(getDeleteProcessUrl(key),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteProcessMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProcess>>, TError,{key: string}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProcess>>, TError,{key: string}, TContext> => {

const mutationKey = ['deleteProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProcess>>, {key: string}> = (props) => {
          const {key} = props ?? {};

          return  deleteProcess(key,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProcessMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProcess>>>
    
    export type DeleteProcessMutationError = void | ErrorResponse

    /**
 * @summary Delete process
 */
export const useDeleteProcess = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProcess>>, TError,{key: string}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProcess>>,
        TError,
        {key: string},
        TContext
      > => {
      return useMutation(getDeleteProcessMutationOptions(options), queryClient);
    }
    /**
 * Assigns classification values to a process. Only the process owner or an admin can assign.
 * @summary Assign classifications to process
 */
export type assignClassificationsToProcessResponse200 = {
  data: ProcessResponse
  status: 200
}

export type assignClassificationsToProcessResponse400 = {
  data: ErrorResponse
  status: 400
}

export type assignClassificationsToProcessResponse401 = {
  data: void
  status: 401
}

export type assignClassificationsToProcessResponse403 = {
  data: void
  status: 403
}

export type assignClassificationsToProcessResponse404 = {
  data: ErrorResponse
  status: 404
}

export type assignClassificationsToProcessResponseSuccess = (assignClassificationsToProcessResponse200) & {
  headers: Headers;
};
export type assignClassificationsToProcessResponseError = (assignClassificationsToProcessResponse400 | assignClassificationsToProcessResponse401 | assignClassificationsToProcessResponse403 | assignClassificationsToProcessResponse404) & {
  headers: Headers;
};

export type assignClassificationsToProcessResponse = (assignClassificationsToProcessResponseSuccess | assignClassificationsToProcessResponseError)

export const getAssignClassificationsToProcessUrl = (key: string,) => {


  

  return `/processes/${key}/classifications`
}

export const assignClassificationsToProcess = async (key: string,
    classificationAssignmentRequest: ClassificationAssignmentRequest[], options?: RequestInit): Promise<assignClassificationsToProcessResponse> => {
  
  return customAxios<assignClassificationsToProcessResponse>(getAssignClassificationsToProcessUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      classificationAssignmentRequest,)
  }
);}




export const getAssignClassificationsToProcessMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToProcess>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToProcess>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext> => {

const mutationKey = ['assignClassificationsToProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignClassificationsToProcess>>, {key: string;data: ClassificationAssignmentRequest[]}> = (props) => {
          const {key,data} = props ?? {};

          return  assignClassificationsToProcess(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AssignClassificationsToProcessMutationResult = NonNullable<Awaited<ReturnType<typeof assignClassificationsToProcess>>>
    export type AssignClassificationsToProcessMutationBody = ClassificationAssignmentRequest[]
    export type AssignClassificationsToProcessMutationError = ErrorResponse | void

    /**
 * @summary Assign classifications to process
 */
export const useAssignClassificationsToProcess = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToProcess>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignClassificationsToProcess>>,
        TError,
        {key: string;data: ClassificationAssignmentRequest[]},
        TContext
      > => {
      return useMutation(getAssignClassificationsToProcessMutationOptions(options), queryClient);
    }
    /**
 * Updates the code of a process and recomputes the key. Only the process owner or an admin can update.
 * @summary Update process code
 */
export type updateProcessCodeResponse200 = {
  data: ProcessResponse
  status: 200
}

export type updateProcessCodeResponse401 = {
  data: void
  status: 401
}

export type updateProcessCodeResponse403 = {
  data: void
  status: 403
}

export type updateProcessCodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateProcessCodeResponseSuccess = (updateProcessCodeResponse200) & {
  headers: Headers;
};
export type updateProcessCodeResponseError = (updateProcessCodeResponse401 | updateProcessCodeResponse403 | updateProcessCodeResponse404) & {
  headers: Headers;
};

export type updateProcessCodeResponse = (updateProcessCodeResponseSuccess | updateProcessCodeResponseError)

export const getUpdateProcessCodeUrl = (key: string,) => {


  

  return `/processes/${key}/code`
}

export const updateProcessCode = async (key: string,
    updateProcessCodeRequest: UpdateProcessCodeRequest, options?: RequestInit): Promise<updateProcessCodeResponse> => {
  
  return customAxios<updateProcessCodeResponse>(getUpdateProcessCodeUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProcessCodeRequest,)
  }
);}




export const getUpdateProcessCodeMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessCode>>, TError,{key: string;data: UpdateProcessCodeRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProcessCode>>, TError,{key: string;data: UpdateProcessCodeRequest}, TContext> => {

const mutationKey = ['updateProcessCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProcessCode>>, {key: string;data: UpdateProcessCodeRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateProcessCode(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProcessCodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateProcessCode>>>
    export type UpdateProcessCodeMutationBody = UpdateProcessCodeRequest
    export type UpdateProcessCodeMutationError = void | ErrorResponse

    /**
 * @summary Update process code
 */
export const useUpdateProcessCode = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessCode>>, TError,{key: string;data: UpdateProcessCodeRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProcessCode>>,
        TError,
        {key: string;data: UpdateProcessCodeRequest},
        TContext
      > => {
      return useMutation(getUpdateProcessCodeMutationOptions(options), queryClient);
    }
    /**
 * Updates the localized descriptions of a process. Only the process owner or an admin can update.
 * @summary Update process descriptions
 */
export type updateProcessDescriptionsResponse200 = {
  data: ProcessResponse
  status: 200
}

export type updateProcessDescriptionsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateProcessDescriptionsResponse401 = {
  data: void
  status: 401
}

export type updateProcessDescriptionsResponse403 = {
  data: void
  status: 403
}

export type updateProcessDescriptionsResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateProcessDescriptionsResponseSuccess = (updateProcessDescriptionsResponse200) & {
  headers: Headers;
};
export type updateProcessDescriptionsResponseError = (updateProcessDescriptionsResponse400 | updateProcessDescriptionsResponse401 | updateProcessDescriptionsResponse403 | updateProcessDescriptionsResponse404) & {
  headers: Headers;
};

export type updateProcessDescriptionsResponse = (updateProcessDescriptionsResponseSuccess | updateProcessDescriptionsResponseError)

export const getUpdateProcessDescriptionsUrl = (key: string,) => {


  

  return `/processes/${key}/descriptions`
}

export const updateProcessDescriptions = async (key: string,
    localizedText: LocalizedText[], options?: RequestInit): Promise<updateProcessDescriptionsResponse> => {
  
  return customAxios<updateProcessDescriptionsResponse>(getUpdateProcessDescriptionsUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      localizedText,)
  }
);}




export const getUpdateProcessDescriptionsMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProcessDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext> => {

const mutationKey = ['updateProcessDescriptions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProcessDescriptions>>, {key: string;data: LocalizedText[]}> = (props) => {
          const {key,data} = props ?? {};

          return  updateProcessDescriptions(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProcessDescriptionsMutationResult = NonNullable<Awaited<ReturnType<typeof updateProcessDescriptions>>>
    export type UpdateProcessDescriptionsMutationBody = LocalizedText[]
    export type UpdateProcessDescriptionsMutationError = ErrorResponse | void

    /**
 * @summary Update process descriptions
 */
export const useUpdateProcessDescriptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProcessDescriptions>>,
        TError,
        {key: string;data: LocalizedText[]},
        TContext
      > => {
      return useMutation(getUpdateProcessDescriptionsMutationOptions(options), queryClient);
    }
    /**
 * Assigns a business domain to a process. Only the process owner or an admin can assign.
 * @summary Assign business domain to process
 */
export type assignBusinessDomainToProcessResponse200 = {
  data: ProcessResponse
  status: 200
}

export type assignBusinessDomainToProcessResponse401 = {
  data: void
  status: 401
}

export type assignBusinessDomainToProcessResponse403 = {
  data: void
  status: 403
}

export type assignBusinessDomainToProcessResponse404 = {
  data: ErrorResponse
  status: 404
}

export type assignBusinessDomainToProcessResponseSuccess = (assignBusinessDomainToProcessResponse200) & {
  headers: Headers;
};
export type assignBusinessDomainToProcessResponseError = (assignBusinessDomainToProcessResponse401 | assignBusinessDomainToProcessResponse403 | assignBusinessDomainToProcessResponse404) & {
  headers: Headers;
};

export type assignBusinessDomainToProcessResponse = (assignBusinessDomainToProcessResponseSuccess | assignBusinessDomainToProcessResponseError)

export const getAssignBusinessDomainToProcessUrl = (key: string,) => {


  

  return `/processes/${key}/domain`
}

export const assignBusinessDomainToProcess = async (key: string,
    assignBusinessDomainRequest: AssignBusinessDomainRequest, options?: RequestInit): Promise<assignBusinessDomainToProcessResponse> => {
  
  return customAxios<assignBusinessDomainToProcessResponse>(getAssignBusinessDomainToProcessUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignBusinessDomainRequest,)
  }
);}




export const getAssignBusinessDomainToProcessMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignBusinessDomainToProcess>>, TError,{key: string;data: AssignBusinessDomainRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof assignBusinessDomainToProcess>>, TError,{key: string;data: AssignBusinessDomainRequest}, TContext> => {

const mutationKey = ['assignBusinessDomainToProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignBusinessDomainToProcess>>, {key: string;data: AssignBusinessDomainRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  assignBusinessDomainToProcess(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AssignBusinessDomainToProcessMutationResult = NonNullable<Awaited<ReturnType<typeof assignBusinessDomainToProcess>>>
    export type AssignBusinessDomainToProcessMutationBody = AssignBusinessDomainRequest
    export type AssignBusinessDomainToProcessMutationError = void | ErrorResponse

    /**
 * @summary Assign business domain to process
 */
export const useAssignBusinessDomainToProcess = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignBusinessDomainToProcess>>, TError,{key: string;data: AssignBusinessDomainRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignBusinessDomainToProcess>>,
        TError,
        {key: string;data: AssignBusinessDomainRequest},
        TContext
      > => {
      return useMutation(getAssignBusinessDomainToProcessMutationOptions(options), queryClient);
    }
    /**
 * Adds a business entity as input to a process. Can reference existing entity or create one on-the-fly.
 * @summary Add input entity to process
 */
export type addProcessInputResponse200 = {
  data: ProcessResponse
  status: 200
}

export type addProcessInputResponse400 = {
  data: ErrorResponse
  status: 400
}

export type addProcessInputResponse401 = {
  data: void
  status: 401
}

export type addProcessInputResponse403 = {
  data: void
  status: 403
}

export type addProcessInputResponse404 = {
  data: ErrorResponse
  status: 404
}

export type addProcessInputResponseSuccess = (addProcessInputResponse200) & {
  headers: Headers;
};
export type addProcessInputResponseError = (addProcessInputResponse400 | addProcessInputResponse401 | addProcessInputResponse403 | addProcessInputResponse404) & {
  headers: Headers;
};

export type addProcessInputResponse = (addProcessInputResponseSuccess | addProcessInputResponseError)

export const getAddProcessInputUrl = (key: string,) => {


  

  return `/processes/${key}/inputs`
}

export const addProcessInput = async (key: string,
    addProcessEntityRequest: AddProcessEntityRequest, options?: RequestInit): Promise<addProcessInputResponse> => {
  
  return customAxios<addProcessInputResponse>(getAddProcessInputUrl(key),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addProcessEntityRequest,)
  }
);}




export const getAddProcessInputMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addProcessInput>>, TError,{key: string;data: AddProcessEntityRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof addProcessInput>>, TError,{key: string;data: AddProcessEntityRequest}, TContext> => {

const mutationKey = ['addProcessInput'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProcessInput>>, {key: string;data: AddProcessEntityRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  addProcessInput(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddProcessInputMutationResult = NonNullable<Awaited<ReturnType<typeof addProcessInput>>>
    export type AddProcessInputMutationBody = AddProcessEntityRequest
    export type AddProcessInputMutationError = ErrorResponse | void

    /**
 * @summary Add input entity to process
 */
export const useAddProcessInput = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addProcessInput>>, TError,{key: string;data: AddProcessEntityRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addProcessInput>>,
        TError,
        {key: string;data: AddProcessEntityRequest},
        TContext
      > => {
      return useMutation(getAddProcessInputMutationOptions(options), queryClient);
    }
    /**
 * Removes a business entity from the process inputs. Only the process owner or an admin can remove.
 * @summary Remove input entity from process
 */
export type removeProcessInputResponse200 = {
  data: ProcessResponse
  status: 200
}

export type removeProcessInputResponse401 = {
  data: void
  status: 401
}

export type removeProcessInputResponse403 = {
  data: void
  status: 403
}

export type removeProcessInputResponse404 = {
  data: ErrorResponse
  status: 404
}

export type removeProcessInputResponseSuccess = (removeProcessInputResponse200) & {
  headers: Headers;
};
export type removeProcessInputResponseError = (removeProcessInputResponse401 | removeProcessInputResponse403 | removeProcessInputResponse404) & {
  headers: Headers;
};

export type removeProcessInputResponse = (removeProcessInputResponseSuccess | removeProcessInputResponseError)

export const getRemoveProcessInputUrl = (key: string,
    entityKey: string,) => {


  

  return `/processes/${key}/inputs/${entityKey}`
}

export const removeProcessInput = async (key: string,
    entityKey: string, options?: RequestInit): Promise<removeProcessInputResponse> => {
  
  return customAxios<removeProcessInputResponse>(getRemoveProcessInputUrl(key,entityKey),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getRemoveProcessInputMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeProcessInput>>, TError,{key: string;entityKey: string}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof removeProcessInput>>, TError,{key: string;entityKey: string}, TContext> => {

const mutationKey = ['removeProcessInput'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeProcessInput>>, {key: string;entityKey: string}> = (props) => {
          const {key,entityKey} = props ?? {};

          return  removeProcessInput(key,entityKey,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveProcessInputMutationResult = NonNullable<Awaited<ReturnType<typeof removeProcessInput>>>
    
    export type RemoveProcessInputMutationError = void | ErrorResponse

    /**
 * @summary Remove input entity from process
 */
export const useRemoveProcessInput = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeProcessInput>>, TError,{key: string;entityKey: string}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeProcessInput>>,
        TError,
        {key: string;entityKey: string},
        TContext
      > => {
      return useMutation(getRemoveProcessInputMutationOptions(options), queryClient);
    }
    /**
 * Updates the localized names of a process. Only the process owner or an admin can update.
 * @summary Update process names
 */
export type updateProcessNamesResponse200 = {
  data: ProcessResponse
  status: 200
}

export type updateProcessNamesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateProcessNamesResponse401 = {
  data: void
  status: 401
}

export type updateProcessNamesResponse403 = {
  data: void
  status: 403
}

export type updateProcessNamesResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateProcessNamesResponseSuccess = (updateProcessNamesResponse200) & {
  headers: Headers;
};
export type updateProcessNamesResponseError = (updateProcessNamesResponse400 | updateProcessNamesResponse401 | updateProcessNamesResponse403 | updateProcessNamesResponse404) & {
  headers: Headers;
};

export type updateProcessNamesResponse = (updateProcessNamesResponseSuccess | updateProcessNamesResponseError)

export const getUpdateProcessNamesUrl = (key: string,) => {


  

  return `/processes/${key}/names`
}

export const updateProcessNames = async (key: string,
    localizedText: LocalizedText[], options?: RequestInit): Promise<updateProcessNamesResponse> => {
  
  return customAxios<updateProcessNamesResponse>(getUpdateProcessNamesUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      localizedText,)
  }
);}




export const getUpdateProcessNamesMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessNames>>, TError,{key: string;data: LocalizedText[]}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProcessNames>>, TError,{key: string;data: LocalizedText[]}, TContext> => {

const mutationKey = ['updateProcessNames'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProcessNames>>, {key: string;data: LocalizedText[]}> = (props) => {
          const {key,data} = props ?? {};

          return  updateProcessNames(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProcessNamesMutationResult = NonNullable<Awaited<ReturnType<typeof updateProcessNames>>>
    export type UpdateProcessNamesMutationBody = LocalizedText[]
    export type UpdateProcessNamesMutationError = ErrorResponse | void

    /**
 * @summary Update process names
 */
export const useUpdateProcessNames = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessNames>>, TError,{key: string;data: LocalizedText[]}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProcessNames>>,
        TError,
        {key: string;data: LocalizedText[]},
        TContext
      > => {
      return useMutation(getUpdateProcessNamesMutationOptions(options), queryClient);
    }
    /**
 * Adds a business entity as output to a process. Can reference existing entity or create one on-the-fly.
 * @summary Add output entity to process
 */
export type addProcessOutputResponse200 = {
  data: ProcessResponse
  status: 200
}

export type addProcessOutputResponse400 = {
  data: ErrorResponse
  status: 400
}

export type addProcessOutputResponse401 = {
  data: void
  status: 401
}

export type addProcessOutputResponse403 = {
  data: void
  status: 403
}

export type addProcessOutputResponse404 = {
  data: ErrorResponse
  status: 404
}

export type addProcessOutputResponseSuccess = (addProcessOutputResponse200) & {
  headers: Headers;
};
export type addProcessOutputResponseError = (addProcessOutputResponse400 | addProcessOutputResponse401 | addProcessOutputResponse403 | addProcessOutputResponse404) & {
  headers: Headers;
};

export type addProcessOutputResponse = (addProcessOutputResponseSuccess | addProcessOutputResponseError)

export const getAddProcessOutputUrl = (key: string,) => {


  

  return `/processes/${key}/outputs`
}

export const addProcessOutput = async (key: string,
    addProcessEntityRequest: AddProcessEntityRequest, options?: RequestInit): Promise<addProcessOutputResponse> => {
  
  return customAxios<addProcessOutputResponse>(getAddProcessOutputUrl(key),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addProcessEntityRequest,)
  }
);}




export const getAddProcessOutputMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addProcessOutput>>, TError,{key: string;data: AddProcessEntityRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof addProcessOutput>>, TError,{key: string;data: AddProcessEntityRequest}, TContext> => {

const mutationKey = ['addProcessOutput'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProcessOutput>>, {key: string;data: AddProcessEntityRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  addProcessOutput(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddProcessOutputMutationResult = NonNullable<Awaited<ReturnType<typeof addProcessOutput>>>
    export type AddProcessOutputMutationBody = AddProcessEntityRequest
    export type AddProcessOutputMutationError = ErrorResponse | void

    /**
 * @summary Add output entity to process
 */
export const useAddProcessOutput = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addProcessOutput>>, TError,{key: string;data: AddProcessEntityRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addProcessOutput>>,
        TError,
        {key: string;data: AddProcessEntityRequest},
        TContext
      > => {
      return useMutation(getAddProcessOutputMutationOptions(options), queryClient);
    }
    /**
 * Removes a business entity from the process outputs. Only the process owner or an admin can remove.
 * @summary Remove output entity from process
 */
export type removeProcessOutputResponse200 = {
  data: ProcessResponse
  status: 200
}

export type removeProcessOutputResponse401 = {
  data: void
  status: 401
}

export type removeProcessOutputResponse403 = {
  data: void
  status: 403
}

export type removeProcessOutputResponse404 = {
  data: ErrorResponse
  status: 404
}

export type removeProcessOutputResponseSuccess = (removeProcessOutputResponse200) & {
  headers: Headers;
};
export type removeProcessOutputResponseError = (removeProcessOutputResponse401 | removeProcessOutputResponse403 | removeProcessOutputResponse404) & {
  headers: Headers;
};

export type removeProcessOutputResponse = (removeProcessOutputResponseSuccess | removeProcessOutputResponseError)

export const getRemoveProcessOutputUrl = (key: string,
    entityKey: string,) => {


  

  return `/processes/${key}/outputs/${entityKey}`
}

export const removeProcessOutput = async (key: string,
    entityKey: string, options?: RequestInit): Promise<removeProcessOutputResponse> => {
  
  return customAxios<removeProcessOutputResponse>(getRemoveProcessOutputUrl(key,entityKey),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getRemoveProcessOutputMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeProcessOutput>>, TError,{key: string;entityKey: string}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof removeProcessOutput>>, TError,{key: string;entityKey: string}, TContext> => {

const mutationKey = ['removeProcessOutput'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeProcessOutput>>, {key: string;entityKey: string}> = (props) => {
          const {key,entityKey} = props ?? {};

          return  removeProcessOutput(key,entityKey,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveProcessOutputMutationResult = NonNullable<Awaited<ReturnType<typeof removeProcessOutput>>>
    
    export type RemoveProcessOutputMutationError = void | ErrorResponse

    /**
 * @summary Remove output entity from process
 */
export const useRemoveProcessOutput = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeProcessOutput>>, TError,{key: string;entityKey: string}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeProcessOutput>>,
        TError,
        {key: string;entityKey: string},
        TContext
      > => {
      return useMutation(getRemoveProcessOutputMutationOptions(options), queryClient);
    }
    /**
 * Updates the owner of a process. Only the current process owner or an admin can update.
 * @summary Update process owner
 */
export type updateProcessOwnerResponse200 = {
  data: ProcessResponse
  status: 200
}

export type updateProcessOwnerResponse401 = {
  data: void
  status: 401
}

export type updateProcessOwnerResponse403 = {
  data: void
  status: 403
}

export type updateProcessOwnerResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateProcessOwnerResponseSuccess = (updateProcessOwnerResponse200) & {
  headers: Headers;
};
export type updateProcessOwnerResponseError = (updateProcessOwnerResponse401 | updateProcessOwnerResponse403 | updateProcessOwnerResponse404) & {
  headers: Headers;
};

export type updateProcessOwnerResponse = (updateProcessOwnerResponseSuccess | updateProcessOwnerResponseError)

export const getUpdateProcessOwnerUrl = (key: string,) => {


  

  return `/processes/${key}/owner`
}

export const updateProcessOwner = async (key: string,
    updateProcessOwnerRequest: UpdateProcessOwnerRequest, options?: RequestInit): Promise<updateProcessOwnerResponse> => {
  
  return customAxios<updateProcessOwnerResponse>(getUpdateProcessOwnerUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProcessOwnerRequest,)
  }
);}




export const getUpdateProcessOwnerMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessOwner>>, TError,{key: string;data: UpdateProcessOwnerRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProcessOwner>>, TError,{key: string;data: UpdateProcessOwnerRequest}, TContext> => {

const mutationKey = ['updateProcessOwner'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProcessOwner>>, {key: string;data: UpdateProcessOwnerRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateProcessOwner(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProcessOwnerMutationResult = NonNullable<Awaited<ReturnType<typeof updateProcessOwner>>>
    export type UpdateProcessOwnerMutationBody = UpdateProcessOwnerRequest
    export type UpdateProcessOwnerMutationError = void | ErrorResponse

    /**
 * @summary Update process owner
 */
export const useUpdateProcessOwner = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessOwner>>, TError,{key: string;data: UpdateProcessOwnerRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProcessOwner>>,
        TError,
        {key: string;data: UpdateProcessOwnerRequest},
        TContext
      > => {
      return useMutation(getUpdateProcessOwnerMutationOptions(options), queryClient);
    }
    /**
 * Updates the type of a process. Only the process owner or an admin can update.
 * @summary Update process type
 */
export type updateProcessTypeResponse200 = {
  data: ProcessResponse
  status: 200
}

export type updateProcessTypeResponse401 = {
  data: void
  status: 401
}

export type updateProcessTypeResponse403 = {
  data: void
  status: 403
}

export type updateProcessTypeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateProcessTypeResponseSuccess = (updateProcessTypeResponse200) & {
  headers: Headers;
};
export type updateProcessTypeResponseError = (updateProcessTypeResponse401 | updateProcessTypeResponse403 | updateProcessTypeResponse404) & {
  headers: Headers;
};

export type updateProcessTypeResponse = (updateProcessTypeResponseSuccess | updateProcessTypeResponseError)

export const getUpdateProcessTypeUrl = (key: string,) => {


  

  return `/processes/${key}/type`
}

export const updateProcessType = async (key: string,
    updateProcessTypeRequest: UpdateProcessTypeRequest, options?: RequestInit): Promise<updateProcessTypeResponse> => {
  
  return customAxios<updateProcessTypeResponse>(getUpdateProcessTypeUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProcessTypeRequest,)
  }
);}




export const getUpdateProcessTypeMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessType>>, TError,{key: string;data: UpdateProcessTypeRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProcessType>>, TError,{key: string;data: UpdateProcessTypeRequest}, TContext> => {

const mutationKey = ['updateProcessType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProcessType>>, {key: string;data: UpdateProcessTypeRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateProcessType(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProcessTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateProcessType>>>
    export type UpdateProcessTypeMutationBody = UpdateProcessTypeRequest
    export type UpdateProcessTypeMutationError = void | ErrorResponse

    /**
 * @summary Update process type
 */
export const useUpdateProcessType = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProcessType>>, TError,{key: string;data: UpdateProcessTypeRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProcessType>>,
        TError,
        {key: string;data: UpdateProcessTypeRequest},
        TContext
      > => {
      return useMutation(getUpdateProcessTypeMutationOptions(options), queryClient);
    }
    /**
 * Returns the version history of a process.
 * @summary Get process version history
 */
export type getProcessVersionsResponse200 = {
  data: ProcessVersionResponse[]
  status: 200
}

export type getProcessVersionsResponse401 = {
  data: void
  status: 401
}

export type getProcessVersionsResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getProcessVersionsResponseSuccess = (getProcessVersionsResponse200) & {
  headers: Headers;
};
export type getProcessVersionsResponseError = (getProcessVersionsResponse401 | getProcessVersionsResponse404) & {
  headers: Headers;
};

export type getProcessVersionsResponse = (getProcessVersionsResponseSuccess | getProcessVersionsResponseError)

export const getGetProcessVersionsUrl = (key: string,) => {


  

  return `/processes/${key}/versions`
}

export const getProcessVersions = async (key: string, options?: RequestInit): Promise<getProcessVersionsResponse> => {
  
  return customAxios<getProcessVersionsResponse>(getGetProcessVersionsUrl(key),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetProcessVersionsQueryKey = (key: string,) => {
    return [
    `/processes/${key}/versions`
    ] as const;
    }

    
export const getGetProcessVersionsQueryOptions = <TData = Awaited<ReturnType<typeof getProcessVersions>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersions>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProcessVersionsQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProcessVersions>>> = ({ signal }) => getProcessVersions(key, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProcessVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProcessVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof getProcessVersions>>>
export type GetProcessVersionsQueryError = void | ErrorResponse


export function useGetProcessVersions<TData = Awaited<ReturnType<typeof getProcessVersions>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessVersions>>,
          TError,
          Awaited<ReturnType<typeof getProcessVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessVersions<TData = Awaited<ReturnType<typeof getProcessVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessVersions>>,
          TError,
          Awaited<ReturnType<typeof getProcessVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessVersions<TData = Awaited<ReturnType<typeof getProcessVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersions>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get process version history
 */

export function useGetProcessVersions<TData = Awaited<ReturnType<typeof getProcessVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersions>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProcessVersionsQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns the diff between a specific version and the previous version.
 * @summary Get diff between process versions
 */
export type getProcessVersionDiffResponse200 = {
  data: VersionDiffResponse
  status: 200
}

export type getProcessVersionDiffResponse401 = {
  data: void
  status: 401
}

export type getProcessVersionDiffResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getProcessVersionDiffResponseSuccess = (getProcessVersionDiffResponse200) & {
  headers: Headers;
};
export type getProcessVersionDiffResponseError = (getProcessVersionDiffResponse401 | getProcessVersionDiffResponse404) & {
  headers: Headers;
};

export type getProcessVersionDiffResponse = (getProcessVersionDiffResponseSuccess | getProcessVersionDiffResponseError)

export const getGetProcessVersionDiffUrl = (key: string,
    versionNumber: number,) => {


  

  return `/processes/${key}/versions/${versionNumber}/diff`
}

export const getProcessVersionDiff = async (key: string,
    versionNumber: number, options?: RequestInit): Promise<getProcessVersionDiffResponse> => {
  
  return customAxios<getProcessVersionDiffResponse>(getGetProcessVersionDiffUrl(key,versionNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetProcessVersionDiffQueryKey = (key: string,
    versionNumber: number,) => {
    return [
    `/processes/${key}/versions/${versionNumber}/diff`
    ] as const;
    }

    
export const getGetProcessVersionDiffQueryOptions = <TData = Awaited<ReturnType<typeof getProcessVersionDiff>>, TError = void | ErrorResponse>(key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersionDiff>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProcessVersionDiffQueryKey(key,versionNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProcessVersionDiff>>> = ({ signal }) => getProcessVersionDiff(key,versionNumber, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(key && versionNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProcessVersionDiff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProcessVersionDiffQueryResult = NonNullable<Awaited<ReturnType<typeof getProcessVersionDiff>>>
export type GetProcessVersionDiffQueryError = void | ErrorResponse


export function useGetProcessVersionDiff<TData = Awaited<ReturnType<typeof getProcessVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersionDiff>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessVersionDiff>>,
          TError,
          Awaited<ReturnType<typeof getProcessVersionDiff>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessVersionDiff<TData = Awaited<ReturnType<typeof getProcessVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersionDiff>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessVersionDiff>>,
          TError,
          Awaited<ReturnType<typeof getProcessVersionDiff>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessVersionDiff<TData = Awaited<ReturnType<typeof getProcessVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersionDiff>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get diff between process versions
 */

export function useGetProcessVersionDiff<TData = Awaited<ReturnType<typeof getProcessVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessVersionDiff>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProcessVersionDiffQueryOptions(key,versionNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns the diagram (elements and flows) of a process.
 * @summary Get process diagram
 */
export type getProcessDiagramResponse200 = {
  data: ProcessDiagramResponse
  status: 200
}

export type getProcessDiagramResponse401 = {
  data: void
  status: 401
}

export type getProcessDiagramResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getProcessDiagramResponseSuccess = (getProcessDiagramResponse200) & {
  headers: Headers;
};
export type getProcessDiagramResponseError = (getProcessDiagramResponse401 | getProcessDiagramResponse404) & {
  headers: Headers;
};

export type getProcessDiagramResponse = (getProcessDiagramResponseSuccess | getProcessDiagramResponseError)

export const getGetProcessDiagramUrl = (key: string,) => {


  

  return `/processes/${key}/diagram`
}

export const getProcessDiagram = async (key: string, options?: RequestInit): Promise<getProcessDiagramResponse> => {
  
  return customAxios<getProcessDiagramResponse>(getGetProcessDiagramUrl(key),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetProcessDiagramQueryKey = (key: string,) => {
    return [
    `/processes/${key}/diagram`
    ] as const;
    }

    
export const getGetProcessDiagramQueryOptions = <TData = Awaited<ReturnType<typeof getProcessDiagram>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessDiagram>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProcessDiagramQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProcessDiagram>>> = ({ signal }) => getProcessDiagram(key, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProcessDiagram>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProcessDiagramQueryResult = NonNullable<Awaited<ReturnType<typeof getProcessDiagram>>>
export type GetProcessDiagramQueryError = void | ErrorResponse


export function useGetProcessDiagram<TData = Awaited<ReturnType<typeof getProcessDiagram>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessDiagram>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessDiagram>>,
          TError,
          Awaited<ReturnType<typeof getProcessDiagram>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessDiagram<TData = Awaited<ReturnType<typeof getProcessDiagram>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessDiagram>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProcessDiagram>>,
          TError,
          Awaited<ReturnType<typeof getProcessDiagram>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProcessDiagram<TData = Awaited<ReturnType<typeof getProcessDiagram>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessDiagram>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get process diagram
 */

export function useGetProcessDiagram<TData = Awaited<ReturnType<typeof getProcessDiagram>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProcessDiagram>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProcessDiagramQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Replaces the entire diagram (elements and flows) of a process. Only the process owner or an admin can save.
 * @summary Save process diagram
 */
export type saveProcessDiagramResponse200 = {
  data: ProcessDiagramResponse
  status: 200
}

export type saveProcessDiagramResponse400 = {
  data: ErrorResponse
  status: 400
}

export type saveProcessDiagramResponse401 = {
  data: void
  status: 401
}

export type saveProcessDiagramResponse403 = {
  data: void
  status: 403
}

export type saveProcessDiagramResponse404 = {
  data: ErrorResponse
  status: 404
}

export type saveProcessDiagramResponseSuccess = (saveProcessDiagramResponse200) & {
  headers: Headers;
};
export type saveProcessDiagramResponseError = (saveProcessDiagramResponse400 | saveProcessDiagramResponse401 | saveProcessDiagramResponse403 | saveProcessDiagramResponse404) & {
  headers: Headers;
};

export type saveProcessDiagramResponse = (saveProcessDiagramResponseSuccess | saveProcessDiagramResponseError)

export const getSaveProcessDiagramUrl = (key: string,) => {


  

  return `/processes/${key}/diagram`
}

export const saveProcessDiagram = async (key: string,
    saveProcessDiagramRequest: SaveProcessDiagramRequest, options?: RequestInit): Promise<saveProcessDiagramResponse> => {
  
  return customAxios<saveProcessDiagramResponse>(getSaveProcessDiagramUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      saveProcessDiagramRequest,)
  }
);}




export const getSaveProcessDiagramMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveProcessDiagram>>, TError,{key: string;data: SaveProcessDiagramRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof saveProcessDiagram>>, TError,{key: string;data: SaveProcessDiagramRequest}, TContext> => {

const mutationKey = ['saveProcessDiagram'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveProcessDiagram>>, {key: string;data: SaveProcessDiagramRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  saveProcessDiagram(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SaveProcessDiagramMutationResult = NonNullable<Awaited<ReturnType<typeof saveProcessDiagram>>>
    export type SaveProcessDiagramMutationBody = SaveProcessDiagramRequest
    export type SaveProcessDiagramMutationError = ErrorResponse | void

    /**
 * @summary Save process diagram
 */
export const useSaveProcessDiagram = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveProcessDiagram>>, TError,{key: string;data: SaveProcessDiagramRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveProcessDiagram>>,
        TError,
        {key: string;data: SaveProcessDiagramRequest},
        TContext
      > => {
      return useMutation(getSaveProcessDiagramMutationOptions(options), queryClient);
    }
    
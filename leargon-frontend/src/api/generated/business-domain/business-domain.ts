/**
 * Generated by orval v8.4.0 ðŸº
 * Do not edit manually.
 * LÃ©argon API
 * REST API for LÃ©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BusinessDomainResponse,
  BusinessDomainTreeResponse,
  BusinessDomainVersionResponse,
  ClassificationAssignmentRequest,
  CreateBusinessDomainRequest,
  ErrorResponse,
  GetLocalizedBusinessDomainParams,
  LocalizedBusinessDomainResponse,
  LocalizedText,
  UpdateBusinessDomainParentRequest,
  UpdateBusinessDomainTypeRequest,
  VersionDiffResponse
} from '.././model';

import { customAxios } from '../../customAxios';




/**
 * Returns a flat list of all business domains with their translations.
 * @summary Get all business domains
 */
export type getAllBusinessDomainsResponse200 = {
  data: BusinessDomainResponse[]
  status: 200
}

export type getAllBusinessDomainsResponse401 = {
  data: void
  status: 401
}

export type getAllBusinessDomainsResponseSuccess = (getAllBusinessDomainsResponse200) & {
  headers: Headers;
};
export type getAllBusinessDomainsResponseError = (getAllBusinessDomainsResponse401) & {
  headers: Headers;
};

export type getAllBusinessDomainsResponse = (getAllBusinessDomainsResponseSuccess | getAllBusinessDomainsResponseError)

export const getGetAllBusinessDomainsUrl = () => {


  

  return `/business-domains`
}

export const getAllBusinessDomains = async ( options?: RequestInit): Promise<getAllBusinessDomainsResponse> => {
  
  return customAxios<getAllBusinessDomainsResponse>(getGetAllBusinessDomainsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAllBusinessDomainsQueryKey = () => {
    return [
    `/business-domains`
    ] as const;
    }

    
export const getGetAllBusinessDomainsQueryOptions = <TData = Awaited<ReturnType<typeof getAllBusinessDomains>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessDomains>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllBusinessDomainsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBusinessDomains>>> = ({ signal }) => getAllBusinessDomains({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessDomains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllBusinessDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBusinessDomains>>>
export type GetAllBusinessDomainsQueryError = void


export function useGetAllBusinessDomains<TData = Awaited<ReturnType<typeof getAllBusinessDomains>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessDomains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBusinessDomains>>,
          TError,
          Awaited<ReturnType<typeof getAllBusinessDomains>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBusinessDomains<TData = Awaited<ReturnType<typeof getAllBusinessDomains>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessDomains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBusinessDomains>>,
          TError,
          Awaited<ReturnType<typeof getAllBusinessDomains>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBusinessDomains<TData = Awaited<ReturnType<typeof getAllBusinessDomains>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessDomains>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all business domains
 */

export function useGetAllBusinessDomains<TData = Awaited<ReturnType<typeof getAllBusinessDomains>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessDomains>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllBusinessDomainsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Creates a new business domain with translations. Requires ROLE_ADMIN.
 * @summary Create a business domain
 */
export type createBusinessDomainResponse201 = {
  data: BusinessDomainResponse
  status: 201
}

export type createBusinessDomainResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createBusinessDomainResponse401 = {
  data: void
  status: 401
}

export type createBusinessDomainResponse403 = {
  data: ErrorResponse
  status: 403
}

export type createBusinessDomainResponseSuccess = (createBusinessDomainResponse201) & {
  headers: Headers;
};
export type createBusinessDomainResponseError = (createBusinessDomainResponse400 | createBusinessDomainResponse401 | createBusinessDomainResponse403) & {
  headers: Headers;
};

export type createBusinessDomainResponse = (createBusinessDomainResponseSuccess | createBusinessDomainResponseError)

export const getCreateBusinessDomainUrl = () => {


  

  return `/business-domains`
}

export const createBusinessDomain = async (createBusinessDomainRequest: CreateBusinessDomainRequest, options?: RequestInit): Promise<createBusinessDomainResponse> => {
  
  return customAxios<createBusinessDomainResponse>(getCreateBusinessDomainUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBusinessDomainRequest,)
  }
);}




export const getCreateBusinessDomainMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBusinessDomain>>, TError,{data: CreateBusinessDomainRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBusinessDomain>>, TError,{data: CreateBusinessDomainRequest}, TContext> => {

const mutationKey = ['createBusinessDomain'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBusinessDomain>>, {data: CreateBusinessDomainRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBusinessDomain(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBusinessDomainMutationResult = NonNullable<Awaited<ReturnType<typeof createBusinessDomain>>>
    export type CreateBusinessDomainMutationBody = CreateBusinessDomainRequest
    export type CreateBusinessDomainMutationError = ErrorResponse | void

    /**
 * @summary Create a business domain
 */
export const useCreateBusinessDomain = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBusinessDomain>>, TError,{data: CreateBusinessDomainRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBusinessDomain>>,
        TError,
        {data: CreateBusinessDomainRequest},
        TContext
      > => {
      return useMutation(getCreateBusinessDomainMutationOptions(options), queryClient);
    }
    /**
 * Returns business domains as a hierarchical tree structure.
 * @summary Get business domain hierarchy
 */
export type getBusinessDomainTreeResponse200 = {
  data: BusinessDomainTreeResponse[]
  status: 200
}

export type getBusinessDomainTreeResponse401 = {
  data: void
  status: 401
}

export type getBusinessDomainTreeResponseSuccess = (getBusinessDomainTreeResponse200) & {
  headers: Headers;
};
export type getBusinessDomainTreeResponseError = (getBusinessDomainTreeResponse401) & {
  headers: Headers;
};

export type getBusinessDomainTreeResponse = (getBusinessDomainTreeResponseSuccess | getBusinessDomainTreeResponseError)

export const getGetBusinessDomainTreeUrl = () => {


  

  return `/business-domains/tree`
}

export const getBusinessDomainTree = async ( options?: RequestInit): Promise<getBusinessDomainTreeResponse> => {
  
  return customAxios<getBusinessDomainTreeResponse>(getGetBusinessDomainTreeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetBusinessDomainTreeQueryKey = () => {
    return [
    `/business-domains/tree`
    ] as const;
    }

    
export const getGetBusinessDomainTreeQueryOptions = <TData = Awaited<ReturnType<typeof getBusinessDomainTree>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBusinessDomainTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBusinessDomainTree>>> = ({ signal }) => getBusinessDomainTree({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBusinessDomainTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getBusinessDomainTree>>>
export type GetBusinessDomainTreeQueryError = void


export function useGetBusinessDomainTree<TData = Awaited<ReturnType<typeof getBusinessDomainTree>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainTree>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainTree>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainTree<TData = Awaited<ReturnType<typeof getBusinessDomainTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainTree>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainTree>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainTree<TData = Awaited<ReturnType<typeof getBusinessDomainTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainTree>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get business domain hierarchy
 */

export function useGetBusinessDomainTree<TData = Awaited<ReturnType<typeof getBusinessDomainTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainTree>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBusinessDomainTreeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns detailed information about a specific business domain including children.
 * @summary Get business domain by key
 */
export type getBusinessDomainByKeyResponse200 = {
  data: BusinessDomainResponse
  status: 200
}

export type getBusinessDomainByKeyResponse401 = {
  data: void
  status: 401
}

export type getBusinessDomainByKeyResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getBusinessDomainByKeyResponseSuccess = (getBusinessDomainByKeyResponse200) & {
  headers: Headers;
};
export type getBusinessDomainByKeyResponseError = (getBusinessDomainByKeyResponse401 | getBusinessDomainByKeyResponse404) & {
  headers: Headers;
};

export type getBusinessDomainByKeyResponse = (getBusinessDomainByKeyResponseSuccess | getBusinessDomainByKeyResponseError)

export const getGetBusinessDomainByKeyUrl = (key: string,) => {


  

  return `/business-domains/${key}`
}

export const getBusinessDomainByKey = async (key: string, options?: RequestInit): Promise<getBusinessDomainByKeyResponse> => {
  
  return customAxios<getBusinessDomainByKeyResponse>(getGetBusinessDomainByKeyUrl(key),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetBusinessDomainByKeyQueryKey = (key: string,) => {
    return [
    `/business-domains/${key}`
    ] as const;
    }

    
export const getGetBusinessDomainByKeyQueryOptions = <TData = Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBusinessDomainByKeyQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBusinessDomainByKey>>> = ({ signal }) => getBusinessDomainByKey(key, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBusinessDomainByKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getBusinessDomainByKey>>>
export type GetBusinessDomainByKeyQueryError = void | ErrorResponse


export function useGetBusinessDomainByKey<TData = Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainByKey>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainByKey>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainByKey<TData = Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainByKey>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainByKey>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainByKey<TData = Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get business domain by key
 */

export function useGetBusinessDomainByKey<TData = Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainByKey>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBusinessDomainByKeyQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Deletes a business domain. Children become top-level domains. Entities are unassigned. Requires ROLE_ADMIN.
 * @summary Delete business domain
 */
export type deleteBusinessDomainResponse204 = {
  data: void
  status: 204
}

export type deleteBusinessDomainResponse401 = {
  data: void
  status: 401
}

export type deleteBusinessDomainResponse403 = {
  data: ErrorResponse
  status: 403
}

export type deleteBusinessDomainResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteBusinessDomainResponseSuccess = (deleteBusinessDomainResponse204) & {
  headers: Headers;
};
export type deleteBusinessDomainResponseError = (deleteBusinessDomainResponse401 | deleteBusinessDomainResponse403 | deleteBusinessDomainResponse404) & {
  headers: Headers;
};

export type deleteBusinessDomainResponse = (deleteBusinessDomainResponseSuccess | deleteBusinessDomainResponseError)

export const getDeleteBusinessDomainUrl = (key: string,) => {


  

  return `/business-domains/${key}`
}

export const deleteBusinessDomain = async (key: string, options?: RequestInit): Promise<deleteBusinessDomainResponse> => {
  
  return customAxios<deleteBusinessDomainResponse>(getDeleteBusinessDomainUrl(key),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteBusinessDomainMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessDomain>>, TError,{key: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessDomain>>, TError,{key: string}, TContext> => {

const mutationKey = ['deleteBusinessDomain'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBusinessDomain>>, {key: string}> = (props) => {
          const {key} = props ?? {};

          return  deleteBusinessDomain(key,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBusinessDomainMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBusinessDomain>>>
    
    export type DeleteBusinessDomainMutationError = void | ErrorResponse

    /**
 * @summary Delete business domain
 */
export const useDeleteBusinessDomain = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessDomain>>, TError,{key: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBusinessDomain>>,
        TError,
        {key: string},
        TContext
      > => {
      return useMutation(getDeleteBusinessDomainMutationOptions(options), queryClient);
    }
    /**
 * Replaces all classification assignments on a business domain. Each classification must be assignable to BUSINESS_DOMAIN and only one value per classification is allowed.
 * @summary Assign classifications to business domain
 */
export type assignClassificationsToDomainResponse200 = {
  data: BusinessDomainResponse
  status: 200
}

export type assignClassificationsToDomainResponse400 = {
  data: ErrorResponse
  status: 400
}

export type assignClassificationsToDomainResponse401 = {
  data: void
  status: 401
}

export type assignClassificationsToDomainResponse403 = {
  data: ErrorResponse
  status: 403
}

export type assignClassificationsToDomainResponse404 = {
  data: ErrorResponse
  status: 404
}

export type assignClassificationsToDomainResponseSuccess = (assignClassificationsToDomainResponse200) & {
  headers: Headers;
};
export type assignClassificationsToDomainResponseError = (assignClassificationsToDomainResponse400 | assignClassificationsToDomainResponse401 | assignClassificationsToDomainResponse403 | assignClassificationsToDomainResponse404) & {
  headers: Headers;
};

export type assignClassificationsToDomainResponse = (assignClassificationsToDomainResponseSuccess | assignClassificationsToDomainResponseError)

export const getAssignClassificationsToDomainUrl = (key: string,) => {


  

  return `/business-domains/${key}/classifications`
}

export const assignClassificationsToDomain = async (key: string,
    classificationAssignmentRequest: ClassificationAssignmentRequest[], options?: RequestInit): Promise<assignClassificationsToDomainResponse> => {
  
  return customAxios<assignClassificationsToDomainResponse>(getAssignClassificationsToDomainUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      classificationAssignmentRequest,)
  }
);}




export const getAssignClassificationsToDomainMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToDomain>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToDomain>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext> => {

const mutationKey = ['assignClassificationsToDomain'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignClassificationsToDomain>>, {key: string;data: ClassificationAssignmentRequest[]}> = (props) => {
          const {key,data} = props ?? {};

          return  assignClassificationsToDomain(key,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AssignClassificationsToDomainMutationResult = NonNullable<Awaited<ReturnType<typeof assignClassificationsToDomain>>>
    export type AssignClassificationsToDomainMutationBody = ClassificationAssignmentRequest[]
    export type AssignClassificationsToDomainMutationError = ErrorResponse | void

    /**
 * @summary Assign classifications to business domain
 */
export const useAssignClassificationsToDomain = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToDomain>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignClassificationsToDomain>>,
        TError,
        {key: string;data: ClassificationAssignmentRequest[]},
        TContext
      > => {
      return useMutation(getAssignClassificationsToDomainMutationOptions(options), queryClient);
    }
    /**
 * Updates the descriptions of a business domain. Requires ROLE_ADMIN.
 * @summary Update business domain descriptions
 */
export type updateBusinessDomainDescriptionsResponse200 = {
  data: BusinessDomainResponse
  status: 200
}

export type updateBusinessDomainDescriptionsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateBusinessDomainDescriptionsResponse401 = {
  data: void
  status: 401
}

export type updateBusinessDomainDescriptionsResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateBusinessDomainDescriptionsResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateBusinessDomainDescriptionsResponseSuccess = (updateBusinessDomainDescriptionsResponse200) & {
  headers: Headers;
};
export type updateBusinessDomainDescriptionsResponseError = (updateBusinessDomainDescriptionsResponse400 | updateBusinessDomainDescriptionsResponse401 | updateBusinessDomainDescriptionsResponse403 | updateBusinessDomainDescriptionsResponse404) & {
  headers: Headers;
};

export type updateBusinessDomainDescriptionsResponse = (updateBusinessDomainDescriptionsResponseSuccess | updateBusinessDomainDescriptionsResponseError)

export const getUpdateBusinessDomainDescriptionsUrl = (key: string,) => {


  

  return `/business-domains/${key}/descriptions`
}

export const updateBusinessDomainDescriptions = async (key: string,
    localizedText: LocalizedText[], options?: RequestInit): Promise<updateBusinessDomainDescriptionsResponse> => {
  
  return customAxios<updateBusinessDomainDescriptionsResponse>(getUpdateBusinessDomainDescriptionsUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      localizedText,)
  }
);}




export const getUpdateBusinessDomainDescriptionsMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext> => {

const mutationKey = ['updateBusinessDomainDescriptions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessDomainDescriptions>>, {key: string;data: LocalizedText[]}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessDomainDescriptions(key,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessDomainDescriptionsMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessDomainDescriptions>>>
    export type UpdateBusinessDomainDescriptionsMutationBody = LocalizedText[]
    export type UpdateBusinessDomainDescriptionsMutationError = ErrorResponse | void

    /**
 * @summary Update business domain descriptions
 */
export const useUpdateBusinessDomainDescriptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessDomainDescriptions>>,
        TError,
        {key: string;data: LocalizedText[]},
        TContext
      > => {
      return useMutation(getUpdateBusinessDomainDescriptionsMutationOptions(options), queryClient);
    }
    /**
 * Returns a single-locale view of a business domain. If no locale parameter given, uses the user's preferred language, falling back to the DB default locale.
 * @summary Get localized business domain
 */
export type getLocalizedBusinessDomainResponse200 = {
  data: LocalizedBusinessDomainResponse
  status: 200
}

export type getLocalizedBusinessDomainResponse401 = {
  data: void
  status: 401
}

export type getLocalizedBusinessDomainResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getLocalizedBusinessDomainResponseSuccess = (getLocalizedBusinessDomainResponse200) & {
  headers: Headers;
};
export type getLocalizedBusinessDomainResponseError = (getLocalizedBusinessDomainResponse401 | getLocalizedBusinessDomainResponse404) & {
  headers: Headers;
};

export type getLocalizedBusinessDomainResponse = (getLocalizedBusinessDomainResponseSuccess | getLocalizedBusinessDomainResponseError)

export const getGetLocalizedBusinessDomainUrl = (key: string,
    params?: GetLocalizedBusinessDomainParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/business-domains/${key}/localized?${stringifiedParams}` : `/business-domains/${key}/localized`
}

export const getLocalizedBusinessDomain = async (key: string,
    params?: GetLocalizedBusinessDomainParams, options?: RequestInit): Promise<getLocalizedBusinessDomainResponse> => {
  
  return customAxios<getLocalizedBusinessDomainResponse>(getGetLocalizedBusinessDomainUrl(key,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetLocalizedBusinessDomainQueryKey = (key: string,
    params?: GetLocalizedBusinessDomainParams,) => {
    return [
    `/business-domains/${key}/localized`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetLocalizedBusinessDomainQueryOptions = <TData = Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError = void | ErrorResponse>(key: string,
    params?: GetLocalizedBusinessDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLocalizedBusinessDomainQueryKey(key,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>> = ({ signal }) => getLocalizedBusinessDomain(key,params, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLocalizedBusinessDomainQueryResult = NonNullable<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>>
export type GetLocalizedBusinessDomainQueryError = void | ErrorResponse


export function useGetLocalizedBusinessDomain<TData = Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError = void | ErrorResponse>(
 key: string,
    params: undefined |  GetLocalizedBusinessDomainParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocalizedBusinessDomain>>,
          TError,
          Awaited<ReturnType<typeof getLocalizedBusinessDomain>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocalizedBusinessDomain<TData = Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError = void | ErrorResponse>(
 key: string,
    params?: GetLocalizedBusinessDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocalizedBusinessDomain>>,
          TError,
          Awaited<ReturnType<typeof getLocalizedBusinessDomain>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocalizedBusinessDomain<TData = Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError = void | ErrorResponse>(
 key: string,
    params?: GetLocalizedBusinessDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get localized business domain
 */

export function useGetLocalizedBusinessDomain<TData = Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError = void | ErrorResponse>(
 key: string,
    params?: GetLocalizedBusinessDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessDomain>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLocalizedBusinessDomainQueryOptions(key,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Updates the names of a business domain. Requires ROLE_ADMIN.
 * @summary Update business domain names
 */
export type updateBusinessDomainNamesResponse200 = {
  data: BusinessDomainResponse
  status: 200
}

export type updateBusinessDomainNamesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateBusinessDomainNamesResponse401 = {
  data: void
  status: 401
}

export type updateBusinessDomainNamesResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateBusinessDomainNamesResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateBusinessDomainNamesResponseSuccess = (updateBusinessDomainNamesResponse200) & {
  headers: Headers;
};
export type updateBusinessDomainNamesResponseError = (updateBusinessDomainNamesResponse400 | updateBusinessDomainNamesResponse401 | updateBusinessDomainNamesResponse403 | updateBusinessDomainNamesResponse404) & {
  headers: Headers;
};

export type updateBusinessDomainNamesResponse = (updateBusinessDomainNamesResponseSuccess | updateBusinessDomainNamesResponseError)

export const getUpdateBusinessDomainNamesUrl = (key: string,) => {


  

  return `/business-domains/${key}/names`
}

export const updateBusinessDomainNames = async (key: string,
    localizedText: LocalizedText[], options?: RequestInit): Promise<updateBusinessDomainNamesResponse> => {
  
  return customAxios<updateBusinessDomainNamesResponse>(getUpdateBusinessDomainNamesUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      localizedText,)
  }
);}




export const getUpdateBusinessDomainNamesMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainNames>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainNames>>, TError,{key: string;data: LocalizedText[]}, TContext> => {

const mutationKey = ['updateBusinessDomainNames'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessDomainNames>>, {key: string;data: LocalizedText[]}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessDomainNames(key,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessDomainNamesMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessDomainNames>>>
    export type UpdateBusinessDomainNamesMutationBody = LocalizedText[]
    export type UpdateBusinessDomainNamesMutationError = ErrorResponse | void

    /**
 * @summary Update business domain names
 */
export const useUpdateBusinessDomainNames = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainNames>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessDomainNames>>,
        TError,
        {key: string;data: LocalizedText[]},
        TContext
      > => {
      return useMutation(getUpdateBusinessDomainNamesMutationOptions(options), queryClient);
    }
    /**
 * Updates the parent of a business domain. Requires ROLE_ADMIN.
 * @summary Update business domain parent
 */
export type updateBusinessDomainParentResponse200 = {
  data: BusinessDomainResponse
  status: 200
}

export type updateBusinessDomainParentResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateBusinessDomainParentResponse401 = {
  data: void
  status: 401
}

export type updateBusinessDomainParentResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateBusinessDomainParentResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateBusinessDomainParentResponseSuccess = (updateBusinessDomainParentResponse200) & {
  headers: Headers;
};
export type updateBusinessDomainParentResponseError = (updateBusinessDomainParentResponse400 | updateBusinessDomainParentResponse401 | updateBusinessDomainParentResponse403 | updateBusinessDomainParentResponse404) & {
  headers: Headers;
};

export type updateBusinessDomainParentResponse = (updateBusinessDomainParentResponseSuccess | updateBusinessDomainParentResponseError)

export const getUpdateBusinessDomainParentUrl = (key: string,) => {


  

  return `/business-domains/${key}/parent`
}

export const updateBusinessDomainParent = async (key: string,
    updateBusinessDomainParentRequest: UpdateBusinessDomainParentRequest, options?: RequestInit): Promise<updateBusinessDomainParentResponse> => {
  
  return customAxios<updateBusinessDomainParentResponse>(getUpdateBusinessDomainParentUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateBusinessDomainParentRequest,)
  }
);}




export const getUpdateBusinessDomainParentMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainParent>>, TError,{key: string;data: UpdateBusinessDomainParentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainParent>>, TError,{key: string;data: UpdateBusinessDomainParentRequest}, TContext> => {

const mutationKey = ['updateBusinessDomainParent'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessDomainParent>>, {key: string;data: UpdateBusinessDomainParentRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessDomainParent(key,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessDomainParentMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessDomainParent>>>
    export type UpdateBusinessDomainParentMutationBody = UpdateBusinessDomainParentRequest
    export type UpdateBusinessDomainParentMutationError = ErrorResponse | void

    /**
 * @summary Update business domain parent
 */
export const useUpdateBusinessDomainParent = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainParent>>, TError,{key: string;data: UpdateBusinessDomainParentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessDomainParent>>,
        TError,
        {key: string;data: UpdateBusinessDomainParentRequest},
        TContext
      > => {
      return useMutation(getUpdateBusinessDomainParentMutationOptions(options), queryClient);
    }
    /**
 * Updates the type of a business domain. Requires ROLE_ADMIN.
 * @summary Update business domain type
 */
export type updateBusinessDomainTypeResponse200 = {
  data: BusinessDomainResponse
  status: 200
}

export type updateBusinessDomainTypeResponse401 = {
  data: void
  status: 401
}

export type updateBusinessDomainTypeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateBusinessDomainTypeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateBusinessDomainTypeResponseSuccess = (updateBusinessDomainTypeResponse200) & {
  headers: Headers;
};
export type updateBusinessDomainTypeResponseError = (updateBusinessDomainTypeResponse401 | updateBusinessDomainTypeResponse403 | updateBusinessDomainTypeResponse404) & {
  headers: Headers;
};

export type updateBusinessDomainTypeResponse = (updateBusinessDomainTypeResponseSuccess | updateBusinessDomainTypeResponseError)

export const getUpdateBusinessDomainTypeUrl = (key: string,) => {


  

  return `/business-domains/${key}/type`
}

export const updateBusinessDomainType = async (key: string,
    updateBusinessDomainTypeRequest: UpdateBusinessDomainTypeRequest, options?: RequestInit): Promise<updateBusinessDomainTypeResponse> => {
  
  return customAxios<updateBusinessDomainTypeResponse>(getUpdateBusinessDomainTypeUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateBusinessDomainTypeRequest,)
  }
);}




export const getUpdateBusinessDomainTypeMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainType>>, TError,{key: string;data: UpdateBusinessDomainTypeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainType>>, TError,{key: string;data: UpdateBusinessDomainTypeRequest}, TContext> => {

const mutationKey = ['updateBusinessDomainType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessDomainType>>, {key: string;data: UpdateBusinessDomainTypeRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessDomainType(key,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessDomainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessDomainType>>>
    export type UpdateBusinessDomainTypeMutationBody = UpdateBusinessDomainTypeRequest
    export type UpdateBusinessDomainTypeMutationError = void | ErrorResponse

    /**
 * @summary Update business domain type
 */
export const useUpdateBusinessDomainType = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessDomainType>>, TError,{key: string;data: UpdateBusinessDomainTypeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessDomainType>>,
        TError,
        {key: string;data: UpdateBusinessDomainTypeRequest},
        TContext
      > => {
      return useMutation(getUpdateBusinessDomainTypeMutationOptions(options), queryClient);
    }
    /**
 * Returns the version history of a business domain.
 * @summary Get business domain version history
 */
export type getBusinessDomainVersionsResponse200 = {
  data: BusinessDomainVersionResponse[]
  status: 200
}

export type getBusinessDomainVersionsResponse401 = {
  data: void
  status: 401
}

export type getBusinessDomainVersionsResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getBusinessDomainVersionsResponseSuccess = (getBusinessDomainVersionsResponse200) & {
  headers: Headers;
};
export type getBusinessDomainVersionsResponseError = (getBusinessDomainVersionsResponse401 | getBusinessDomainVersionsResponse404) & {
  headers: Headers;
};

export type getBusinessDomainVersionsResponse = (getBusinessDomainVersionsResponseSuccess | getBusinessDomainVersionsResponseError)

export const getGetBusinessDomainVersionsUrl = (key: string,) => {


  

  return `/business-domains/${key}/versions`
}

export const getBusinessDomainVersions = async (key: string, options?: RequestInit): Promise<getBusinessDomainVersionsResponse> => {
  
  return customAxios<getBusinessDomainVersionsResponse>(getGetBusinessDomainVersionsUrl(key),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetBusinessDomainVersionsQueryKey = (key: string,) => {
    return [
    `/business-domains/${key}/versions`
    ] as const;
    }

    
export const getGetBusinessDomainVersionsQueryOptions = <TData = Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBusinessDomainVersionsQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBusinessDomainVersions>>> = ({ signal }) => getBusinessDomainVersions(key, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBusinessDomainVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof getBusinessDomainVersions>>>
export type GetBusinessDomainVersionsQueryError = void | ErrorResponse


export function useGetBusinessDomainVersions<TData = Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainVersions>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainVersions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainVersions<TData = Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainVersions>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainVersions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainVersions<TData = Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get business domain version history
 */

export function useGetBusinessDomainVersions<TData = Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBusinessDomainVersionsQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns the diff between a specific version and the previous version.
 * @summary Get diff between domain versions
 */
export type getBusinessDomainVersionDiffResponse200 = {
  data: VersionDiffResponse
  status: 200
}

export type getBusinessDomainVersionDiffResponse401 = {
  data: void
  status: 401
}

export type getBusinessDomainVersionDiffResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getBusinessDomainVersionDiffResponseSuccess = (getBusinessDomainVersionDiffResponse200) & {
  headers: Headers;
};
export type getBusinessDomainVersionDiffResponseError = (getBusinessDomainVersionDiffResponse401 | getBusinessDomainVersionDiffResponse404) & {
  headers: Headers;
};

export type getBusinessDomainVersionDiffResponse = (getBusinessDomainVersionDiffResponseSuccess | getBusinessDomainVersionDiffResponseError)

export const getGetBusinessDomainVersionDiffUrl = (key: string,
    versionNumber: number,) => {


  

  return `/business-domains/${key}/versions/${versionNumber}/diff`
}

export const getBusinessDomainVersionDiff = async (key: string,
    versionNumber: number, options?: RequestInit): Promise<getBusinessDomainVersionDiffResponse> => {
  
  return customAxios<getBusinessDomainVersionDiffResponse>(getGetBusinessDomainVersionDiffUrl(key,versionNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetBusinessDomainVersionDiffQueryKey = (key: string,
    versionNumber: number,) => {
    return [
    `/business-domains/${key}/versions/${versionNumber}/diff`
    ] as const;
    }

    
export const getGetBusinessDomainVersionDiffQueryOptions = <TData = Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError = void | ErrorResponse>(key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBusinessDomainVersionDiffQueryKey(key,versionNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>> = ({ signal }) => getBusinessDomainVersionDiff(key,versionNumber, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(key && versionNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBusinessDomainVersionDiffQueryResult = NonNullable<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>>
export type GetBusinessDomainVersionDiffQueryError = void | ErrorResponse


export function useGetBusinessDomainVersionDiff<TData = Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainVersionDiff<TData = Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>,
          TError,
          Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessDomainVersionDiff<TData = Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get diff between domain versions
 */

export function useGetBusinessDomainVersionDiff<TData = Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessDomainVersionDiff>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBusinessDomainVersionDiffQueryOptions(key,versionNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





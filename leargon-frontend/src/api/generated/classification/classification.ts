/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * LÃ©argon API
 * REST API for LÃ©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ClassificationResponse,
  CreateClassificationRequest,
  CreateClassificationValueRequest,
  ErrorResponse,
  GetClassificationsParams,
  UpdateClassificationRequest,
  UpdateClassificationValueRequest
} from '.././model';

import { customAxios } from '../../customAxios';




/**
 * Get classifications with filtering by 'assignable to' or none
 * @summary Get classifications with filter by type
 */
export const getClassifications = (
    params?: GetClassificationsParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ClassificationResponse[]>(
      {url: `/classifications`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetClassificationsQueryKey = (params?: GetClassificationsParams,) => {
    return [
    `/classifications`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetClassificationsQueryOptions = <TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassifications>>> = ({ signal }) => getClassifications(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClassificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getClassifications>>>
export type GetClassificationsQueryError = void


export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params: undefined |  GetClassificationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassifications>>,
          TError,
          Awaited<ReturnType<typeof getClassifications>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassifications>>,
          TError,
          Awaited<ReturnType<typeof getClassifications>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get classifications with filter by type
 */

export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClassificationsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new classification taxonomy. Requires ROLE_ADMIN.
 * @summary Create a classification
 */
export const createClassification = (
    createClassificationRequest: CreateClassificationRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ClassificationResponse>(
      {url: `/classifications`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createClassificationRequest, signal
    },
      );
    }
  


export const getCreateClassificationMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: CreateClassificationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: CreateClassificationRequest}, TContext> => {

const mutationKey = ['createClassification'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClassification>>, {data: CreateClassificationRequest}> = (props) => {
          const {data} = props ?? {};

          return  createClassification(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createClassification>>>
    export type CreateClassificationMutationBody = CreateClassificationRequest
    export type CreateClassificationMutationError = ErrorResponse | void

    /**
 * @summary Create a classification
 */
export const useCreateClassification = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: CreateClassificationRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createClassification>>,
        TError,
        {data: CreateClassificationRequest},
        TContext
      > => {

      const mutationOptions = getCreateClassificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Returns detailed information about a specific classification including its values.
 * @summary Get classification by key
 */
export const getClassificationByKey = (
    key: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ClassificationResponse>(
      {url: `/classifications/${key}`, method: 'GET', signal
    },
      );
    }
  



export const getGetClassificationByKeyQueryKey = (key?: string,) => {
    return [
    `/classifications/${key}`
    ] as const;
    }

    
export const getGetClassificationByKeyQueryOptions = <TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationByKeyQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationByKey>>> = ({ signal }) => getClassificationByKey(key, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClassificationByKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationByKey>>>
export type GetClassificationByKeyQueryError = void | ErrorResponse


export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationByKey>>,
          TError,
          Awaited<ReturnType<typeof getClassificationByKey>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationByKey>>,
          TError,
          Awaited<ReturnType<typeof getClassificationByKey>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get classification by key
 */

export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClassificationByKeyQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a classification's names, descriptions, and optional flag. AssignableTo is immutable. Requires ROLE_ADMIN.
 * @summary Update classification
 */
export const updateClassification = (
    key: string,
    updateClassificationRequest: UpdateClassificationRequest,
 ) => {
      
      
      return customAxios<ClassificationResponse>(
      {url: `/classifications/${key}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateClassificationRequest
    },
      );
    }
  


export const getUpdateClassificationMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{key: string;data: UpdateClassificationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{key: string;data: UpdateClassificationRequest}, TContext> => {

const mutationKey = ['updateClassification'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClassification>>, {key: string;data: UpdateClassificationRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateClassification(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateClassification>>>
    export type UpdateClassificationMutationBody = UpdateClassificationRequest
    export type UpdateClassificationMutationError = ErrorResponse | void

    /**
 * @summary Update classification
 */
export const useUpdateClassification = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{key: string;data: UpdateClassificationRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateClassification>>,
        TError,
        {key: string;data: UpdateClassificationRequest},
        TContext
      > => {

      const mutationOptions = getUpdateClassificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Permanently deletes a classification and all its values. Removes assignments from entities/domains. Requires ROLE_ADMIN.
 * @summary Delete classification
 */
export const deleteClassification = (
    key: string,
 ) => {
      
      
      return customAxios<void>(
      {url: `/classifications/${key}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteClassificationMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{key: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{key: string}, TContext> => {

const mutationKey = ['deleteClassification'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClassification>>, {key: string}> = (props) => {
          const {key} = props ?? {};

          return  deleteClassification(key,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClassification>>>
    
    export type DeleteClassificationMutationError = void | ErrorResponse

    /**
 * @summary Delete classification
 */
export const useDeleteClassification = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{key: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteClassification>>,
        TError,
        {key: string},
        TContext
      > => {

      const mutationOptions = getDeleteClassificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Adds a new value to a classification. Requires ROLE_ADMIN.
 * @summary Create a classification value
 */
export const createClassificationValue = (
    key: string,
    createClassificationValueRequest: CreateClassificationValueRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ClassificationResponse>(
      {url: `/classifications/${key}/values`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createClassificationValueRequest, signal
    },
      );
    }
  


export const getCreateClassificationValueMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassificationValue>>, TError,{key: string;data: CreateClassificationValueRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createClassificationValue>>, TError,{key: string;data: CreateClassificationValueRequest}, TContext> => {

const mutationKey = ['createClassificationValue'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClassificationValue>>, {key: string;data: CreateClassificationValueRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  createClassificationValue(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClassificationValueMutationResult = NonNullable<Awaited<ReturnType<typeof createClassificationValue>>>
    export type CreateClassificationValueMutationBody = CreateClassificationValueRequest
    export type CreateClassificationValueMutationError = ErrorResponse | void

    /**
 * @summary Create a classification value
 */
export const useCreateClassificationValue = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassificationValue>>, TError,{key: string;data: CreateClassificationValueRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createClassificationValue>>,
        TError,
        {key: string;data: CreateClassificationValueRequest},
        TContext
      > => {

      const mutationOptions = getCreateClassificationValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Updates a classification value's names and descriptions. Requires ROLE_ADMIN.
 * @summary Update a classification value
 */
export const updateClassificationValue = (
    key: string,
    valueKey: string,
    updateClassificationValueRequest: UpdateClassificationValueRequest,
 ) => {
      
      
      return customAxios<ClassificationResponse>(
      {url: `/classifications/${key}/values/${valueKey}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateClassificationValueRequest
    },
      );
    }
  


export const getUpdateClassificationValueMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassificationValue>>, TError,{key: string;valueKey: string;data: UpdateClassificationValueRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateClassificationValue>>, TError,{key: string;valueKey: string;data: UpdateClassificationValueRequest}, TContext> => {

const mutationKey = ['updateClassificationValue'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClassificationValue>>, {key: string;valueKey: string;data: UpdateClassificationValueRequest}> = (props) => {
          const {key,valueKey,data} = props ?? {};

          return  updateClassificationValue(key,valueKey,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClassificationValueMutationResult = NonNullable<Awaited<ReturnType<typeof updateClassificationValue>>>
    export type UpdateClassificationValueMutationBody = UpdateClassificationValueRequest
    export type UpdateClassificationValueMutationError = ErrorResponse | void

    /**
 * @summary Update a classification value
 */
export const useUpdateClassificationValue = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassificationValue>>, TError,{key: string;valueKey: string;data: UpdateClassificationValueRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateClassificationValue>>,
        TError,
        {key: string;valueKey: string;data: UpdateClassificationValueRequest},
        TContext
      > => {

      const mutationOptions = getUpdateClassificationValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Deletes a classification value. Removes assignments referencing this value. Requires ROLE_ADMIN.
 * @summary Delete a classification value
 */
export const deleteClassificationValue = (
    key: string,
    valueKey: string,
 ) => {
      
      
      return customAxios<void>(
      {url: `/classifications/${key}/values/${valueKey}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteClassificationValueMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassificationValue>>, TError,{key: string;valueKey: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteClassificationValue>>, TError,{key: string;valueKey: string}, TContext> => {

const mutationKey = ['deleteClassificationValue'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClassificationValue>>, {key: string;valueKey: string}> = (props) => {
          const {key,valueKey} = props ?? {};

          return  deleteClassificationValue(key,valueKey,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClassificationValueMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClassificationValue>>>
    
    export type DeleteClassificationValueMutationError = void | ErrorResponse

    /**
 * @summary Delete a classification value
 */
export const useDeleteClassificationValue = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassificationValue>>, TError,{key: string;valueKey: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteClassificationValue>>,
        TError,
        {key: string;valueKey: string},
        TContext
      > => {

      const mutationOptions = getDeleteClassificationValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
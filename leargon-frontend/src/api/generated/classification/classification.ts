/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * L√©argon API
 * REST API for L√©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ClassificationResponse,
  CreateClassificationRequest,
  CreateClassificationValueRequest,
  ErrorResponse,
  GetClassificationsParams,
  UpdateClassificationRequest,
  UpdateClassificationValueRequest
} from '.././model';

import { customAxios } from '../../customAxios';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get classifications with filtering by 'assignable to' or none
 * @summary Get classifications with filter by type
 */
export type getClassificationsResponse200 = {
  data: ClassificationResponse[]
  status: 200
}

export type getClassificationsResponse401 = {
  data: void
  status: 401
}

export type getClassificationsResponseSuccess = (getClassificationsResponse200) & {
  headers: Headers;
};
export type getClassificationsResponseError = (getClassificationsResponse401) & {
  headers: Headers;
};

export type getClassificationsResponse = (getClassificationsResponseSuccess | getClassificationsResponseError)

export const getGetClassificationsUrl = (params?: GetClassificationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/classifications?${stringifiedParams}` : `/classifications`
}

export const getClassifications = async (params?: GetClassificationsParams, options?: RequestInit): Promise<getClassificationsResponse> => {
  
  return customAxios<getClassificationsResponse>(getGetClassificationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetClassificationsQueryKey = (params?: GetClassificationsParams,) => {
    return [
    `/classifications`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetClassificationsQueryOptions = <TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassifications>>> = ({ signal }) => getClassifications(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClassificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getClassifications>>>
export type GetClassificationsQueryError = void


export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params: undefined |  GetClassificationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassifications>>,
          TError,
          Awaited<ReturnType<typeof getClassifications>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassifications>>,
          TError,
          Awaited<ReturnType<typeof getClassifications>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get classifications with filter by type
 */

export function useGetClassifications<TData = Awaited<ReturnType<typeof getClassifications>>, TError = void>(
 params?: GetClassificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassifications>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClassificationsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Creates a new classification taxonomy. Requires ROLE_ADMIN.
 * @summary Create a classification
 */
export type createClassificationResponse201 = {
  data: ClassificationResponse
  status: 201
}

export type createClassificationResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createClassificationResponse401 = {
  data: void
  status: 401
}

export type createClassificationResponse403 = {
  data: void
  status: 403
}

export type createClassificationResponseSuccess = (createClassificationResponse201) & {
  headers: Headers;
};
export type createClassificationResponseError = (createClassificationResponse400 | createClassificationResponse401 | createClassificationResponse403) & {
  headers: Headers;
};

export type createClassificationResponse = (createClassificationResponseSuccess | createClassificationResponseError)

export const getCreateClassificationUrl = () => {


  

  return `/classifications`
}

export const createClassification = async (createClassificationRequest: CreateClassificationRequest, options?: RequestInit): Promise<createClassificationResponse> => {
  
  return customAxios<createClassificationResponse>(getCreateClassificationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createClassificationRequest,)
  }
);}




export const getCreateClassificationMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: CreateClassificationRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: CreateClassificationRequest}, TContext> => {

const mutationKey = ['createClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClassification>>, {data: CreateClassificationRequest}> = (props) => {
          const {data} = props ?? {};

          return  createClassification(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createClassification>>>
    export type CreateClassificationMutationBody = CreateClassificationRequest
    export type CreateClassificationMutationError = ErrorResponse | void

    /**
 * @summary Create a classification
 */
export const useCreateClassification = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: CreateClassificationRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createClassification>>,
        TError,
        {data: CreateClassificationRequest},
        TContext
      > => {
      return useMutation(getCreateClassificationMutationOptions(options), queryClient);
    }
    /**
 * Returns detailed information about a specific classification including its values.
 * @summary Get classification by key
 */
export type getClassificationByKeyResponse200 = {
  data: ClassificationResponse
  status: 200
}

export type getClassificationByKeyResponse401 = {
  data: void
  status: 401
}

export type getClassificationByKeyResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getClassificationByKeyResponseSuccess = (getClassificationByKeyResponse200) & {
  headers: Headers;
};
export type getClassificationByKeyResponseError = (getClassificationByKeyResponse401 | getClassificationByKeyResponse404) & {
  headers: Headers;
};

export type getClassificationByKeyResponse = (getClassificationByKeyResponseSuccess | getClassificationByKeyResponseError)

export const getGetClassificationByKeyUrl = (key: string,) => {


  

  return `/classifications/${key}`
}

export const getClassificationByKey = async (key: string, options?: RequestInit): Promise<getClassificationByKeyResponse> => {
  
  return customAxios<getClassificationByKeyResponse>(getGetClassificationByKeyUrl(key),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetClassificationByKeyQueryKey = (key: string,) => {
    return [
    `/classifications/${key}`
    ] as const;
    }

    
export const getGetClassificationByKeyQueryOptions = <TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationByKeyQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationByKey>>> = ({ signal }) => getClassificationByKey(key, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClassificationByKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationByKey>>>
export type GetClassificationByKeyQueryError = void | ErrorResponse


export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationByKey>>,
          TError,
          Awaited<ReturnType<typeof getClassificationByKey>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationByKey>>,
          TError,
          Awaited<ReturnType<typeof getClassificationByKey>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get classification by key
 */

export function useGetClassificationByKey<TData = Awaited<ReturnType<typeof getClassificationByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationByKey>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClassificationByKeyQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Updates a classification's names, descriptions, and optional flag. AssignableTo is immutable. Requires ROLE_ADMIN.
 * @summary Update classification
 */
export type updateClassificationResponse200 = {
  data: ClassificationResponse
  status: 200
}

export type updateClassificationResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateClassificationResponse401 = {
  data: void
  status: 401
}

export type updateClassificationResponse403 = {
  data: void
  status: 403
}

export type updateClassificationResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateClassificationResponseSuccess = (updateClassificationResponse200) & {
  headers: Headers;
};
export type updateClassificationResponseError = (updateClassificationResponse400 | updateClassificationResponse401 | updateClassificationResponse403 | updateClassificationResponse404) & {
  headers: Headers;
};

export type updateClassificationResponse = (updateClassificationResponseSuccess | updateClassificationResponseError)

export const getUpdateClassificationUrl = (key: string,) => {


  

  return `/classifications/${key}`
}

export const updateClassification = async (key: string,
    updateClassificationRequest: UpdateClassificationRequest, options?: RequestInit): Promise<updateClassificationResponse> => {
  
  return customAxios<updateClassificationResponse>(getUpdateClassificationUrl(key),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateClassificationRequest,)
  }
);}




export const getUpdateClassificationMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{key: string;data: UpdateClassificationRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{key: string;data: UpdateClassificationRequest}, TContext> => {

const mutationKey = ['updateClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClassification>>, {key: string;data: UpdateClassificationRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateClassification(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateClassification>>>
    export type UpdateClassificationMutationBody = UpdateClassificationRequest
    export type UpdateClassificationMutationError = ErrorResponse | void

    /**
 * @summary Update classification
 */
export const useUpdateClassification = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{key: string;data: UpdateClassificationRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateClassification>>,
        TError,
        {key: string;data: UpdateClassificationRequest},
        TContext
      > => {
      return useMutation(getUpdateClassificationMutationOptions(options), queryClient);
    }
    /**
 * Permanently deletes a classification and all its values. Removes assignments from entities/domains. Requires ROLE_ADMIN.
 * @summary Delete classification
 */
export type deleteClassificationResponse204 = {
  data: void
  status: 204
}

export type deleteClassificationResponse401 = {
  data: void
  status: 401
}

export type deleteClassificationResponse403 = {
  data: void
  status: 403
}

export type deleteClassificationResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteClassificationResponseSuccess = (deleteClassificationResponse204) & {
  headers: Headers;
};
export type deleteClassificationResponseError = (deleteClassificationResponse401 | deleteClassificationResponse403 | deleteClassificationResponse404) & {
  headers: Headers;
};

export type deleteClassificationResponse = (deleteClassificationResponseSuccess | deleteClassificationResponseError)

export const getDeleteClassificationUrl = (key: string,) => {


  

  return `/classifications/${key}`
}

export const deleteClassification = async (key: string, options?: RequestInit): Promise<deleteClassificationResponse> => {
  
  return customAxios<deleteClassificationResponse>(getDeleteClassificationUrl(key),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteClassificationMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{key: string}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{key: string}, TContext> => {

const mutationKey = ['deleteClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClassification>>, {key: string}> = (props) => {
          const {key} = props ?? {};

          return  deleteClassification(key,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClassification>>>
    
    export type DeleteClassificationMutationError = void | ErrorResponse

    /**
 * @summary Delete classification
 */
export const useDeleteClassification = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{key: string}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteClassification>>,
        TError,
        {key: string},
        TContext
      > => {
      return useMutation(getDeleteClassificationMutationOptions(options), queryClient);
    }
    /**
 * Adds a new value to a classification. Requires ROLE_ADMIN.
 * @summary Create a classification value
 */
export type createClassificationValueResponse201 = {
  data: ClassificationResponse
  status: 201
}

export type createClassificationValueResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createClassificationValueResponse401 = {
  data: void
  status: 401
}

export type createClassificationValueResponse403 = {
  data: void
  status: 403
}

export type createClassificationValueResponse404 = {
  data: ErrorResponse
  status: 404
}

export type createClassificationValueResponseSuccess = (createClassificationValueResponse201) & {
  headers: Headers;
};
export type createClassificationValueResponseError = (createClassificationValueResponse400 | createClassificationValueResponse401 | createClassificationValueResponse403 | createClassificationValueResponse404) & {
  headers: Headers;
};

export type createClassificationValueResponse = (createClassificationValueResponseSuccess | createClassificationValueResponseError)

export const getCreateClassificationValueUrl = (key: string,) => {


  

  return `/classifications/${key}/values`
}

export const createClassificationValue = async (key: string,
    createClassificationValueRequest: CreateClassificationValueRequest, options?: RequestInit): Promise<createClassificationValueResponse> => {
  
  return customAxios<createClassificationValueResponse>(getCreateClassificationValueUrl(key),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createClassificationValueRequest,)
  }
);}




export const getCreateClassificationValueMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassificationValue>>, TError,{key: string;data: CreateClassificationValueRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof createClassificationValue>>, TError,{key: string;data: CreateClassificationValueRequest}, TContext> => {

const mutationKey = ['createClassificationValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClassificationValue>>, {key: string;data: CreateClassificationValueRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  createClassificationValue(key,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClassificationValueMutationResult = NonNullable<Awaited<ReturnType<typeof createClassificationValue>>>
    export type CreateClassificationValueMutationBody = CreateClassificationValueRequest
    export type CreateClassificationValueMutationError = ErrorResponse | void

    /**
 * @summary Create a classification value
 */
export const useCreateClassificationValue = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassificationValue>>, TError,{key: string;data: CreateClassificationValueRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createClassificationValue>>,
        TError,
        {key: string;data: CreateClassificationValueRequest},
        TContext
      > => {
      return useMutation(getCreateClassificationValueMutationOptions(options), queryClient);
    }
    /**
 * Updates a classification value's names and descriptions. Requires ROLE_ADMIN.
 * @summary Update a classification value
 */
export type updateClassificationValueResponse200 = {
  data: ClassificationResponse
  status: 200
}

export type updateClassificationValueResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateClassificationValueResponse401 = {
  data: void
  status: 401
}

export type updateClassificationValueResponse403 = {
  data: void
  status: 403
}

export type updateClassificationValueResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateClassificationValueResponseSuccess = (updateClassificationValueResponse200) & {
  headers: Headers;
};
export type updateClassificationValueResponseError = (updateClassificationValueResponse400 | updateClassificationValueResponse401 | updateClassificationValueResponse403 | updateClassificationValueResponse404) & {
  headers: Headers;
};

export type updateClassificationValueResponse = (updateClassificationValueResponseSuccess | updateClassificationValueResponseError)

export const getUpdateClassificationValueUrl = (key: string,
    valueKey: string,) => {


  

  return `/classifications/${key}/values/${valueKey}`
}

export const updateClassificationValue = async (key: string,
    valueKey: string,
    updateClassificationValueRequest: UpdateClassificationValueRequest, options?: RequestInit): Promise<updateClassificationValueResponse> => {
  
  return customAxios<updateClassificationValueResponse>(getUpdateClassificationValueUrl(key,valueKey),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateClassificationValueRequest,)
  }
);}




export const getUpdateClassificationValueMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassificationValue>>, TError,{key: string;valueKey: string;data: UpdateClassificationValueRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof updateClassificationValue>>, TError,{key: string;valueKey: string;data: UpdateClassificationValueRequest}, TContext> => {

const mutationKey = ['updateClassificationValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClassificationValue>>, {key: string;valueKey: string;data: UpdateClassificationValueRequest}> = (props) => {
          const {key,valueKey,data} = props ?? {};

          return  updateClassificationValue(key,valueKey,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClassificationValueMutationResult = NonNullable<Awaited<ReturnType<typeof updateClassificationValue>>>
    export type UpdateClassificationValueMutationBody = UpdateClassificationValueRequest
    export type UpdateClassificationValueMutationError = ErrorResponse | void

    /**
 * @summary Update a classification value
 */
export const useUpdateClassificationValue = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassificationValue>>, TError,{key: string;valueKey: string;data: UpdateClassificationValueRequest}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateClassificationValue>>,
        TError,
        {key: string;valueKey: string;data: UpdateClassificationValueRequest},
        TContext
      > => {
      return useMutation(getUpdateClassificationValueMutationOptions(options), queryClient);
    }
    /**
 * Deletes a classification value. Removes assignments referencing this value. Requires ROLE_ADMIN.
 * @summary Delete a classification value
 */
export type deleteClassificationValueResponse204 = {
  data: void
  status: 204
}

export type deleteClassificationValueResponse401 = {
  data: void
  status: 401
}

export type deleteClassificationValueResponse403 = {
  data: void
  status: 403
}

export type deleteClassificationValueResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteClassificationValueResponseSuccess = (deleteClassificationValueResponse204) & {
  headers: Headers;
};
export type deleteClassificationValueResponseError = (deleteClassificationValueResponse401 | deleteClassificationValueResponse403 | deleteClassificationValueResponse404) & {
  headers: Headers;
};

export type deleteClassificationValueResponse = (deleteClassificationValueResponseSuccess | deleteClassificationValueResponseError)

export const getDeleteClassificationValueUrl = (key: string,
    valueKey: string,) => {


  

  return `/classifications/${key}/values/${valueKey}`
}

export const deleteClassificationValue = async (key: string,
    valueKey: string, options?: RequestInit): Promise<deleteClassificationValueResponse> => {
  
  return customAxios<deleteClassificationValueResponse>(getDeleteClassificationValueUrl(key,valueKey),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteClassificationValueMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassificationValue>>, TError,{key: string;valueKey: string}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteClassificationValue>>, TError,{key: string;valueKey: string}, TContext> => {

const mutationKey = ['deleteClassificationValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClassificationValue>>, {key: string;valueKey: string}> = (props) => {
          const {key,valueKey} = props ?? {};

          return  deleteClassificationValue(key,valueKey,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClassificationValueMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClassificationValue>>>
    
    export type DeleteClassificationValueMutationError = void | ErrorResponse

    /**
 * @summary Delete a classification value
 */
export const useDeleteClassificationValue = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassificationValue>>, TError,{key: string;valueKey: string}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteClassificationValue>>,
        TError,
        {key: string;valueKey: string},
        TContext
      > => {
      return useMutation(getDeleteClassificationValueMutationOptions(options), queryClient);
    }
    
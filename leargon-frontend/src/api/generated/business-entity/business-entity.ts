/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * LÃ©argon API
 * REST API for LÃ©argon data and process governance platform.

## Authentication
The API uses JWT (JSON Web Token) based authentication. After logging in or signing up, you will receive an access token that must be included in the `Authorization` header as a Bearer token for protected endpoints.

## Authorization Roles
- **ROLE_USER**: Standard user role, assigned to all users by default
- **ROLE_ADMIN**: Administrative role with full user management capabilities

## Fallback Administration Protection
The system includes a fallback admin user that cannot be modified or deleted through the API. Any attempt to modify this user will result in a 403 Forbidden response.

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssignBusinessDomainRequest,
  BusinessEntityResponse,
  BusinessEntityTreeResponse,
  BusinessEntityVersionResponse,
  ClassificationAssignmentRequest,
  CreateBusinessEntityRelationshipRequest,
  CreateBusinessEntityRequest,
  ErrorResponse,
  GetLocalizedBusinessEntityParams,
  LocalizedBusinessEntityResponse,
  LocalizedText,
  UpdateBusinessEntityDataOwnerRequest,
  UpdateBusinessEntityInterfacesRequest,
  UpdateBusinessEntityParentRequest,
  UpdateBusinessEntityRelationshipRequest,
  VersionDiffResponse
} from '.././model';

import { customAxios } from '../../customAxios';




/**
 * Returns a list of all entities with their translations.
 * @summary Get all entities
 */
export const getAllBusinessEntities = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<BusinessEntityResponse[]>(
      {url: `/business-entities`, method: 'GET', signal
    },
      );
    }
  



export const getGetAllBusinessEntitiesQueryKey = () => {
    return [
    `/business-entities`
    ] as const;
    }

    
export const getGetAllBusinessEntitiesQueryOptions = <TData = Awaited<ReturnType<typeof getAllBusinessEntities>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessEntities>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllBusinessEntitiesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBusinessEntities>>> = ({ signal }) => getAllBusinessEntities(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessEntities>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllBusinessEntitiesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBusinessEntities>>>
export type GetAllBusinessEntitiesQueryError = void


export function useGetAllBusinessEntities<TData = Awaited<ReturnType<typeof getAllBusinessEntities>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessEntities>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBusinessEntities>>,
          TError,
          Awaited<ReturnType<typeof getAllBusinessEntities>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBusinessEntities<TData = Awaited<ReturnType<typeof getAllBusinessEntities>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessEntities>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBusinessEntities>>,
          TError,
          Awaited<ReturnType<typeof getAllBusinessEntities>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBusinessEntities<TData = Awaited<ReturnType<typeof getAllBusinessEntities>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessEntities>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all entities
 */

export function useGetAllBusinessEntities<TData = Awaited<ReturnType<typeof getAllBusinessEntities>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBusinessEntities>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllBusinessEntitiesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new entity with translations. The creator becomes the Data Owner by default.
 * @summary Create an entity
 */
export const createBusinessEntity = (
    createBusinessEntityRequest: CreateBusinessEntityRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBusinessEntityRequest, signal
    },
      );
    }
  


export const getCreateBusinessEntityMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBusinessEntity>>, TError,{data: CreateBusinessEntityRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBusinessEntity>>, TError,{data: CreateBusinessEntityRequest}, TContext> => {

const mutationKey = ['createBusinessEntity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBusinessEntity>>, {data: CreateBusinessEntityRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBusinessEntity(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBusinessEntityMutationResult = NonNullable<Awaited<ReturnType<typeof createBusinessEntity>>>
    export type CreateBusinessEntityMutationBody = CreateBusinessEntityRequest
    export type CreateBusinessEntityMutationError = ErrorResponse | void

    /**
 * @summary Create an entity
 */
export const useCreateBusinessEntity = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBusinessEntity>>, TError,{data: CreateBusinessEntityRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBusinessEntity>>,
        TError,
        {data: CreateBusinessEntityRequest},
        TContext
      > => {

      const mutationOptions = getCreateBusinessEntityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Returns business entities as a hierarchical tree structure.
 * @summary Get business entity hierarchy
 */
export const getBusinessEntityTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<BusinessEntityTreeResponse[]>(
      {url: `/business-entities/tree`, method: 'GET', signal
    },
      );
    }
  



export const getGetBusinessEntityTreeQueryKey = () => {
    return [
    `/business-entities/tree`
    ] as const;
    }

    
export const getGetBusinessEntityTreeQueryOptions = <TData = Awaited<ReturnType<typeof getBusinessEntityTree>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBusinessEntityTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBusinessEntityTree>>> = ({ signal }) => getBusinessEntityTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBusinessEntityTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getBusinessEntityTree>>>
export type GetBusinessEntityTreeQueryError = void


export function useGetBusinessEntityTree<TData = Awaited<ReturnType<typeof getBusinessEntityTree>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessEntityTree>>,
          TError,
          Awaited<ReturnType<typeof getBusinessEntityTree>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessEntityTree<TData = Awaited<ReturnType<typeof getBusinessEntityTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessEntityTree>>,
          TError,
          Awaited<ReturnType<typeof getBusinessEntityTree>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessEntityTree<TData = Awaited<ReturnType<typeof getBusinessEntityTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityTree>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get business entity hierarchy
 */

export function useGetBusinessEntityTree<TData = Awaited<ReturnType<typeof getBusinessEntityTree>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityTree>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBusinessEntityTreeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns detailed information about a specific business entity including all translations.
 * @summary Get business entity by key
 */
export const getBusinessEntityByKey = (
    key: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}`, method: 'GET', signal
    },
      );
    }
  



export const getGetBusinessEntityByKeyQueryKey = (key?: string,) => {
    return [
    `/business-entities/${key}`
    ] as const;
    }

    
export const getGetBusinessEntityByKeyQueryOptions = <TData = Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBusinessEntityByKeyQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBusinessEntityByKey>>> = ({ signal }) => getBusinessEntityByKey(key, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBusinessEntityByKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getBusinessEntityByKey>>>
export type GetBusinessEntityByKeyQueryError = void | ErrorResponse


export function useGetBusinessEntityByKey<TData = Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessEntityByKey>>,
          TError,
          Awaited<ReturnType<typeof getBusinessEntityByKey>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessEntityByKey<TData = Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBusinessEntityByKey>>,
          TError,
          Awaited<ReturnType<typeof getBusinessEntityByKey>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBusinessEntityByKey<TData = Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get business entity by key
 */

export function useGetBusinessEntityByKey<TData = Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBusinessEntityByKey>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBusinessEntityByKeyQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Permanently deletes an business entity. Only the Data Owner or an Administrator can delete an entity.
 * @summary Delete business entity
 */
export const deleteBusinessEntity = (
    key: string,
 ) => {
      
      
      return customAxios<void>(
      {url: `/business-entities/${key}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBusinessEntityMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessEntity>>, TError,{key: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessEntity>>, TError,{key: string}, TContext> => {

const mutationKey = ['deleteBusinessEntity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBusinessEntity>>, {key: string}> = (props) => {
          const {key} = props ?? {};

          return  deleteBusinessEntity(key,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBusinessEntityMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBusinessEntity>>>
    
    export type DeleteBusinessEntityMutationError = void | ErrorResponse

    /**
 * @summary Delete business entity
 */
export const useDeleteBusinessEntity = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessEntity>>, TError,{key: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBusinessEntity>>,
        TError,
        {key: string},
        TContext
      > => {

      const mutationOptions = getDeleteBusinessEntityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Replaces all classification assignments on a business entity. Each classification must be assignable to BUSINESS_ENTITY and only one value per classification is allowed.
 * @summary Assign classifications to business entity
 */
export const assignClassificationsToEntity = (
    key: string,
    classificationAssignmentRequest: ClassificationAssignmentRequest[],
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/classifications`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: classificationAssignmentRequest
    },
      );
    }
  


export const getAssignClassificationsToEntityMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToEntity>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToEntity>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext> => {

const mutationKey = ['assignClassificationsToEntity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignClassificationsToEntity>>, {key: string;data: ClassificationAssignmentRequest[]}> = (props) => {
          const {key,data} = props ?? {};

          return  assignClassificationsToEntity(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignClassificationsToEntityMutationResult = NonNullable<Awaited<ReturnType<typeof assignClassificationsToEntity>>>
    export type AssignClassificationsToEntityMutationBody = ClassificationAssignmentRequest[]
    export type AssignClassificationsToEntityMutationError = ErrorResponse | void

    /**
 * @summary Assign classifications to business entity
 */
export const useAssignClassificationsToEntity = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignClassificationsToEntity>>, TError,{key: string;data: ClassificationAssignmentRequest[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignClassificationsToEntity>>,
        TError,
        {key: string;data: ClassificationAssignmentRequest[]},
        TContext
      > => {

      const mutationOptions = getAssignClassificationsToEntityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Updates the data owner of a business entity. Only the Data Owner or an Administrator can edit an entity.
 * @summary Update business entity data owner
 */
export const updateBusinessEntityDataOwner = (
    key: string,
    updateBusinessEntityDataOwnerRequest: UpdateBusinessEntityDataOwnerRequest,
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/data-owner`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBusinessEntityDataOwnerRequest
    },
      );
    }
  


export const getUpdateBusinessEntityDataOwnerMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityDataOwner>>, TError,{key: string;data: UpdateBusinessEntityDataOwnerRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityDataOwner>>, TError,{key: string;data: UpdateBusinessEntityDataOwnerRequest}, TContext> => {

const mutationKey = ['updateBusinessEntityDataOwner'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessEntityDataOwner>>, {key: string;data: UpdateBusinessEntityDataOwnerRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessEntityDataOwner(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessEntityDataOwnerMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessEntityDataOwner>>>
    export type UpdateBusinessEntityDataOwnerMutationBody = UpdateBusinessEntityDataOwnerRequest
    export type UpdateBusinessEntityDataOwnerMutationError = void | ErrorResponse

    /**
 * @summary Update business entity data owner
 */
export const useUpdateBusinessEntityDataOwner = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityDataOwner>>, TError,{key: string;data: UpdateBusinessEntityDataOwnerRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessEntityDataOwner>>,
        TError,
        {key: string;data: UpdateBusinessEntityDataOwnerRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBusinessEntityDataOwnerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Replaces all descriptions of a business entity. Only the Data Owner or an Administrator can edit an entity.
 * @summary Update business entity descriptions
 */
export const updateBusinessEntityDescriptions = (
    key: string,
    localizedText: LocalizedText[],
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/descriptions`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: localizedText
    },
      );
    }
  


export const getUpdateBusinessEntityDescriptionsMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext> => {

const mutationKey = ['updateBusinessEntityDescriptions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessEntityDescriptions>>, {key: string;data: LocalizedText[]}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessEntityDescriptions(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessEntityDescriptionsMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessEntityDescriptions>>>
    export type UpdateBusinessEntityDescriptionsMutationBody = LocalizedText[]
    export type UpdateBusinessEntityDescriptionsMutationError = ErrorResponse | void

    /**
 * @summary Update business entity descriptions
 */
export const useUpdateBusinessEntityDescriptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityDescriptions>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessEntityDescriptions>>,
        TError,
        {key: string;data: LocalizedText[]},
        TContext
      > => {

      const mutationOptions = getUpdateBusinessEntityDescriptionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Assigns a business domain to an business entity. Only the Data Owner or an Administrator can assign domains.
 * @summary Assign business domain to business entity
 */
export const assignBusinessDomainToBusinessEntity = (
    key: string,
    assignBusinessDomainRequest: AssignBusinessDomainRequest,
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/domain`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assignBusinessDomainRequest
    },
      );
    }
  


export const getAssignBusinessDomainToBusinessEntityMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignBusinessDomainToBusinessEntity>>, TError,{key: string;data: AssignBusinessDomainRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignBusinessDomainToBusinessEntity>>, TError,{key: string;data: AssignBusinessDomainRequest}, TContext> => {

const mutationKey = ['assignBusinessDomainToBusinessEntity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignBusinessDomainToBusinessEntity>>, {key: string;data: AssignBusinessDomainRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  assignBusinessDomainToBusinessEntity(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignBusinessDomainToBusinessEntityMutationResult = NonNullable<Awaited<ReturnType<typeof assignBusinessDomainToBusinessEntity>>>
    export type AssignBusinessDomainToBusinessEntityMutationBody = AssignBusinessDomainRequest
    export type AssignBusinessDomainToBusinessEntityMutationError = ErrorResponse | void

    /**
 * @summary Assign business domain to business entity
 */
export const useAssignBusinessDomainToBusinessEntity = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignBusinessDomainToBusinessEntity>>, TError,{key: string;data: AssignBusinessDomainRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignBusinessDomainToBusinessEntity>>,
        TError,
        {key: string;data: AssignBusinessDomainRequest},
        TContext
      > => {

      const mutationOptions = getAssignBusinessDomainToBusinessEntityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Updates the interface entities of a business entity. Only the Data Owner or an Administrator can edit an entity.
 * @summary Update business entity interfaces
 */
export const updateBusinessEntityInterfaces = (
    key: string,
    updateBusinessEntityInterfacesRequest: UpdateBusinessEntityInterfacesRequest,
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/interfaces`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBusinessEntityInterfacesRequest
    },
      );
    }
  


export const getUpdateBusinessEntityInterfacesMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityInterfaces>>, TError,{key: string;data: UpdateBusinessEntityInterfacesRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityInterfaces>>, TError,{key: string;data: UpdateBusinessEntityInterfacesRequest}, TContext> => {

const mutationKey = ['updateBusinessEntityInterfaces'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessEntityInterfaces>>, {key: string;data: UpdateBusinessEntityInterfacesRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessEntityInterfaces(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessEntityInterfacesMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessEntityInterfaces>>>
    export type UpdateBusinessEntityInterfacesMutationBody = UpdateBusinessEntityInterfacesRequest
    export type UpdateBusinessEntityInterfacesMutationError = ErrorResponse | void

    /**
 * @summary Update business entity interfaces
 */
export const useUpdateBusinessEntityInterfaces = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityInterfaces>>, TError,{key: string;data: UpdateBusinessEntityInterfacesRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessEntityInterfaces>>,
        TError,
        {key: string;data: UpdateBusinessEntityInterfacesRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBusinessEntityInterfacesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Returns a single-locale view of a business entity. If no locale parameter given, uses the user's preferred language, falling back to the DB default locale.
 * @summary Get localized business entity
 */
export const getLocalizedBusinessEntity = (
    key: string,
    params?: GetLocalizedBusinessEntityParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<LocalizedBusinessEntityResponse>(
      {url: `/business-entities/${key}/localized`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetLocalizedBusinessEntityQueryKey = (key?: string,
    params?: GetLocalizedBusinessEntityParams,) => {
    return [
    `/business-entities/${key}/localized`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetLocalizedBusinessEntityQueryOptions = <TData = Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError = void | ErrorResponse>(key: string,
    params?: GetLocalizedBusinessEntityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLocalizedBusinessEntityQueryKey(key,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>> = ({ signal }) => getLocalizedBusinessEntity(key,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLocalizedBusinessEntityQueryResult = NonNullable<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>>
export type GetLocalizedBusinessEntityQueryError = void | ErrorResponse


export function useGetLocalizedBusinessEntity<TData = Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError = void | ErrorResponse>(
 key: string,
    params: undefined |  GetLocalizedBusinessEntityParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocalizedBusinessEntity>>,
          TError,
          Awaited<ReturnType<typeof getLocalizedBusinessEntity>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocalizedBusinessEntity<TData = Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError = void | ErrorResponse>(
 key: string,
    params?: GetLocalizedBusinessEntityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocalizedBusinessEntity>>,
          TError,
          Awaited<ReturnType<typeof getLocalizedBusinessEntity>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocalizedBusinessEntity<TData = Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError = void | ErrorResponse>(
 key: string,
    params?: GetLocalizedBusinessEntityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get localized business entity
 */

export function useGetLocalizedBusinessEntity<TData = Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError = void | ErrorResponse>(
 key: string,
    params?: GetLocalizedBusinessEntityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocalizedBusinessEntity>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLocalizedBusinessEntityQueryOptions(key,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces names of a business entity. Only the Data Owner or an Administrator can edit an entity.
 * @summary Update business entity names
 */
export const updateBusinessEntityNames = (
    key: string,
    localizedText: LocalizedText[],
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/names`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: localizedText
    },
      );
    }
  


export const getUpdateBusinessEntityNamesMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityNames>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityNames>>, TError,{key: string;data: LocalizedText[]}, TContext> => {

const mutationKey = ['updateBusinessEntityNames'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessEntityNames>>, {key: string;data: LocalizedText[]}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessEntityNames(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessEntityNamesMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessEntityNames>>>
    export type UpdateBusinessEntityNamesMutationBody = LocalizedText[]
    export type UpdateBusinessEntityNamesMutationError = ErrorResponse | void

    /**
 * @summary Update business entity names
 */
export const useUpdateBusinessEntityNames = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityNames>>, TError,{key: string;data: LocalizedText[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessEntityNames>>,
        TError,
        {key: string;data: LocalizedText[]},
        TContext
      > => {

      const mutationOptions = getUpdateBusinessEntityNamesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Updates the parent of a business entity. Only the Data Owner or an Administrator can edit an entity.
 * @summary Update business entity parent
 */
export const updateBusinessEntityParent = (
    key: string,
    updateBusinessEntityParentRequest: UpdateBusinessEntityParentRequest,
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/parent`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBusinessEntityParentRequest
    },
      );
    }
  


export const getUpdateBusinessEntityParentMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityParent>>, TError,{key: string;data: UpdateBusinessEntityParentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityParent>>, TError,{key: string;data: UpdateBusinessEntityParentRequest}, TContext> => {

const mutationKey = ['updateBusinessEntityParent'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessEntityParent>>, {key: string;data: UpdateBusinessEntityParentRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  updateBusinessEntityParent(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessEntityParentMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessEntityParent>>>
    export type UpdateBusinessEntityParentMutationBody = UpdateBusinessEntityParentRequest
    export type UpdateBusinessEntityParentMutationError = ErrorResponse | void

    /**
 * @summary Update business entity parent
 */
export const useUpdateBusinessEntityParent = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityParent>>, TError,{key: string;data: UpdateBusinessEntityParentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessEntityParent>>,
        TError,
        {key: string;data: UpdateBusinessEntityParentRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBusinessEntityParentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Creates a relationship between this entity and another entity. Only the Data Owner or an Administrator can create relationships.
 * @summary Create a relationship
 */
export const createBusinessEntityRelationship = (
    key: string,
    createBusinessEntityRelationshipRequest: CreateBusinessEntityRelationshipRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/relationships`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBusinessEntityRelationshipRequest, signal
    },
      );
    }
  


export const getCreateBusinessEntityRelationshipMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBusinessEntityRelationship>>, TError,{key: string;data: CreateBusinessEntityRelationshipRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBusinessEntityRelationship>>, TError,{key: string;data: CreateBusinessEntityRelationshipRequest}, TContext> => {

const mutationKey = ['createBusinessEntityRelationship'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBusinessEntityRelationship>>, {key: string;data: CreateBusinessEntityRelationshipRequest}> = (props) => {
          const {key,data} = props ?? {};

          return  createBusinessEntityRelationship(key,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBusinessEntityRelationshipMutationResult = NonNullable<Awaited<ReturnType<typeof createBusinessEntityRelationship>>>
    export type CreateBusinessEntityRelationshipMutationBody = CreateBusinessEntityRelationshipRequest
    export type CreateBusinessEntityRelationshipMutationError = ErrorResponse | void

    /**
 * @summary Create a relationship
 */
export const useCreateBusinessEntityRelationship = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBusinessEntityRelationship>>, TError,{key: string;data: CreateBusinessEntityRelationshipRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBusinessEntityRelationship>>,
        TError,
        {key: string;data: CreateBusinessEntityRelationshipRequest},
        TContext
      > => {

      const mutationOptions = getCreateBusinessEntityRelationshipMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Updates cardinalities and descriptions of a relationship. Only the Data Owner or an Administrator can update relationships.
 * @summary Update a relationship
 */
export const updateBusinessEntityRelationship = (
    key: string,
    relationshipId: number,
    updateBusinessEntityRelationshipRequest: UpdateBusinessEntityRelationshipRequest,
 ) => {
      
      
      return customAxios<BusinessEntityResponse>(
      {url: `/business-entities/${key}/relationships/${relationshipId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBusinessEntityRelationshipRequest
    },
      );
    }
  


export const getUpdateBusinessEntityRelationshipMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityRelationship>>, TError,{key: string;relationshipId: number;data: UpdateBusinessEntityRelationshipRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityRelationship>>, TError,{key: string;relationshipId: number;data: UpdateBusinessEntityRelationshipRequest}, TContext> => {

const mutationKey = ['updateBusinessEntityRelationship'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBusinessEntityRelationship>>, {key: string;relationshipId: number;data: UpdateBusinessEntityRelationshipRequest}> = (props) => {
          const {key,relationshipId,data} = props ?? {};

          return  updateBusinessEntityRelationship(key,relationshipId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBusinessEntityRelationshipMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessEntityRelationship>>>
    export type UpdateBusinessEntityRelationshipMutationBody = UpdateBusinessEntityRelationshipRequest
    export type UpdateBusinessEntityRelationshipMutationError = ErrorResponse | void

    /**
 * @summary Update a relationship
 */
export const useUpdateBusinessEntityRelationship = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBusinessEntityRelationship>>, TError,{key: string;relationshipId: number;data: UpdateBusinessEntityRelationshipRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBusinessEntityRelationship>>,
        TError,
        {key: string;relationshipId: number;data: UpdateBusinessEntityRelationshipRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBusinessEntityRelationshipMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Deletes a relationship between entities. Only the Data Owner or an Administrator can delete relationships.
 * @summary Delete a relationship
 */
export const deleteBusinessEntityRelationship = (
    key: string,
    relationshipId: number,
 ) => {
      
      
      return customAxios<void>(
      {url: `/business-entities/${key}/relationships/${relationshipId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBusinessEntityRelationshipMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessEntityRelationship>>, TError,{key: string;relationshipId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessEntityRelationship>>, TError,{key: string;relationshipId: number}, TContext> => {

const mutationKey = ['deleteBusinessEntityRelationship'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBusinessEntityRelationship>>, {key: string;relationshipId: number}> = (props) => {
          const {key,relationshipId} = props ?? {};

          return  deleteBusinessEntityRelationship(key,relationshipId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBusinessEntityRelationshipMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBusinessEntityRelationship>>>
    
    export type DeleteBusinessEntityRelationshipMutationError = void | ErrorResponse

    /**
 * @summary Delete a relationship
 */
export const useDeleteBusinessEntityRelationship = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBusinessEntityRelationship>>, TError,{key: string;relationshipId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBusinessEntityRelationship>>,
        TError,
        {key: string;relationshipId: number},
        TContext
      > => {

      const mutationOptions = getDeleteBusinessEntityRelationshipMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Returns the version history of an business entity.
 * @summary Get business entity version history
 */
export const getVersions = (
    key: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<BusinessEntityVersionResponse[]>(
      {url: `/business-entities/${key}/versions`, method: 'GET', signal
    },
      );
    }
  



export const getGetVersionsQueryKey = (key?: string,) => {
    return [
    `/business-entities/${key}/versions`
    ] as const;
    }

    
export const getGetVersionsQueryOptions = <TData = Awaited<ReturnType<typeof getVersions>>, TError = void | ErrorResponse>(key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionsQueryKey(key);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersions>>> = ({ signal }) => getVersions(key, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof getVersions>>>
export type GetVersionsQueryError = void | ErrorResponse


export function useGetVersions<TData = Awaited<ReturnType<typeof getVersions>>, TError = void | ErrorResponse>(
 key: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersions>>,
          TError,
          Awaited<ReturnType<typeof getVersions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersions<TData = Awaited<ReturnType<typeof getVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersions>>,
          TError,
          Awaited<ReturnType<typeof getVersions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersions<TData = Awaited<ReturnType<typeof getVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get business entity version history
 */

export function useGetVersions<TData = Awaited<ReturnType<typeof getVersions>>, TError = void | ErrorResponse>(
 key: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVersionsQueryOptions(key,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the diff between a specific version and the previous version.
 * @summary Get diff between versions
 */
export const getVersionDiff = (
    key: string,
    versionNumber: number,
 signal?: AbortSignal
) => {
      
      
      return customAxios<VersionDiffResponse>(
      {url: `/business-entities/${key}/versions/${versionNumber}/diff`, method: 'GET', signal
    },
      );
    }
  



export const getGetVersionDiffQueryKey = (key?: string,
    versionNumber?: number,) => {
    return [
    `/business-entities/${key}/versions/${versionNumber}/diff`
    ] as const;
    }

    
export const getGetVersionDiffQueryOptions = <TData = Awaited<ReturnType<typeof getVersionDiff>>, TError = void | ErrorResponse>(key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionDiff>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionDiffQueryKey(key,versionNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionDiff>>> = ({ signal }) => getVersionDiff(key,versionNumber, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key && versionNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionDiff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVersionDiffQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionDiff>>>
export type GetVersionDiffQueryError = void | ErrorResponse


export function useGetVersionDiff<TData = Awaited<ReturnType<typeof getVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionDiff>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionDiff>>,
          TError,
          Awaited<ReturnType<typeof getVersionDiff>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersionDiff<TData = Awaited<ReturnType<typeof getVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionDiff>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionDiff>>,
          TError,
          Awaited<ReturnType<typeof getVersionDiff>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersionDiff<TData = Awaited<ReturnType<typeof getVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionDiff>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get diff between versions
 */

export function useGetVersionDiff<TData = Awaited<ReturnType<typeof getVersionDiff>>, TError = void | ErrorResponse>(
 key: string,
    versionNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionDiff>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVersionDiffQueryOptions(key,versionNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




